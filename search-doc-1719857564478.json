{"searchDocs":[{"title":"Considerations","type":0,"sectionRef":"#","url":"/nestjs-cls/considerations","content":"Considerations This chapter exists to help you decide whether this library is compatible with your project and to address any concerns that you may have. You might be also interested in the Author's take","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Security","type":0,"sectionRef":"#","url":"/nestjs-cls/considerations/security","content":"Security It is often discussed whether AsyncLocalStorage is safe to use for concurrent requests (because of a possible context leak) and whether the context could be lost throughout the duration of a request. The ClsMiddleware and ClsInterceptor by default uses the safe run() method, which it should not leak context, but in some rare cases, the context can be lost. The ClsGuard (and ClsMiddleware, if configured so) uses the less safe enterWith() method, which might be needed in case the run() method causes context loss. This has a consequence that should be taken into account: caution When the enterWith method is used, any consequent requests get access to the CLS context of the previous request until the request hits the enterWith call. That means, when using ClsMiddleware with the useEnterWith option, or ClsGuard to set up context, be sure to mount them as early in the request lifetime as possible and do not use any other enhancers that rely on ClsService before them. For ClsGuard, that means you should probably manually mount it in AppModule if you require any other guard to run after it. The next chapter addresses compatibility with various transport protocols.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Features and use cases","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases","content":"Features and use cases In addition to the basic functionality described in the Quick start chapter, this module provides several other features to make your life as a developer easier.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"API","type":0,"sectionRef":"#","url":"/nestjs-cls/api","content":"API This chapter describes the programmatic API of the ClsService and the ClsModule options.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Service Interface","type":0,"sectionRef":"#","url":"/nestjs-cls/api/service-interface","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"ClsService​","type":1,"pageTitle":"Service Interface","url":"/nestjs-cls/api/service-interface#clsservice","content":" The injectable ClsService provides the following API to manipulate the cls context:  The S type parameter is used as the type of custom ClsStore.  get(): S Get the entire CLS context. get(key?: keyof S): S[key] Retrieve a value from the CLS context by key. getId(): string; Retrieve the request ID (a shorthand for cls.get(CLS_ID)) has(key: keyof S): boolean Check if a key is in the CLS context. set(key: keyof S, value: S[key]): void Set a value on the CLS context. setIfUndefined(key: keyof S, value: S[key]): void Set a value on the CLS context only if it hasn't been already set. Useful for ensuring idempotence if you have multiple entry points. run(callback: () =&gt; T): T run(options: ClsContextOptions, callback: () =&gt; T): T; Run the callback in a shared CLS context. Optionally takes an options object as the first parameter. runWith(store: S, callback: () =&gt; T): T Run the callback in a new CLS context (while supplying the default store). enter(): void; enter(options: ClsContextOptions): void Run any following code in a shared CLS context. Optionally takes an options object as the first parameter. enterWith(store: S): void Run any following code in a new CLS context (while supplying the default store). exit(callback: () =&gt; T): T Run the callback without access to a shared CLS context. isActive(): boolean Whether the current code runs within an active CLS context.  The following methods only apply to the Proxy feature:  getProxy(proxyToken: any): any Retrieve a Proxy provider from the CLS context based on its injection token. setProxy(proxyToken: any, value? any): any Replace an instance of a Proxy provider in the CLS context based on its injection token. resolveProxyProviders(proxyTokens?: any[]): Promise&lt;void&gt; Manually trigger resolution of registered Proxy Providers. If an array of injection tokens is provided, resolves only those Proxy Providers.  The following methods involve the plugin lifecycle:  initializePlugins(): Promise&lt;void&gt; Manually trigger onClsInit hooks of registered plugins.  ","version":"Next","tagName":"h2"},{"title":"ClsContextOptions​","type":1,"pageTitle":"Service Interface","url":"/nestjs-cls/api/service-interface#clscontextoptions","content":" The run and enter methods can take an additional options object with the following settings:  ifNested?:'inherit' | 'reuse' | 'override' Sets the behavior of nested CLS context creation in case the method is invoked in an existing context. It has no effect if no parent context exist. inherit (default) - Run the callback with a shallow copy of the parent context. Re-assignments of top-level properties will not be reflected in the parent context. However, modifications of existing properties will be reflected.reuse - Reuse existing context without creating a new one. All modifications to the existing context will be reflected.override - Run the callback with an new empty context. No values from the parent context will be accessible within the wrapped code.  ::: Note  Until v4, the default behavior was override. This was changed to inherit since v4 to make the behavior more intuitive.  ::: ","version":"Next","tagName":"h2"},{"title":"Additional CLS Setup","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/additional-cls-setup","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Middleware​","type":1,"pageTitle":"Additional CLS Setup","url":"/nestjs-cls/features-and-use-cases/additional-cls-setup#middleware","content":" In case of middleware the Request and Response objects are passed as the second and third parameters.  ClsModule.forRoot({ middleware: { mount: true, setup: (cls, req: Request, res: Response) =&gt; { cls.set('TENANT_ID', req.params('tenant_id')); cls.set('AUTH', { authenticated: false }); }, }, });   ","version":"Next","tagName":"h2"},{"title":"Enhancers​","type":1,"pageTitle":"Additional CLS Setup","url":"/nestjs-cls/features-and-use-cases/additional-cls-setup#enhancers","content":" In a guard or interceptor, the ExecutionContext object is passed as a second parameter.  ClsModule.forRoot({ interceptor: { mount: true, setup: (cls, context) =&gt; { const req = context.switchToHttp().getRequest&lt;Request&gt;(); cls.set('TENANT_ID', req.params('tenant_id')); cls.set('AUTH', { authenticated: false }); }, }, });  ","version":"Next","tagName":"h2"},{"title":"Module Options","type":0,"sectionRef":"#","url":"/nestjs-cls/api/module-options","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"forRoot(Async)​","type":1,"pageTitle":"Module Options","url":"/nestjs-cls/api/module-options#forrootasync","content":" The ClsModule.forRoot() method takes the following ClsModuleOptions:  middleware?:ClsMiddlewareOptions An object with additional options for the ClsMiddleware, see below. guard?:ClsGuardOptions An object with additional options for the ClsGuard, see below. interceptor?:ClsInterceptorOptions An object with additional options for the ClsInterceptor, see below. global?:boolean** (default false) Whether to make the module global, so you do not have to import ClsModule.forFeature() in other modules. proxyProviders?:Type[] Array of Proxy Providers that should be registered in the root module. Currently only accepts sync class Proxy providers, use ClsModule.forFeatureAsync() for more complex use-cases.  ClsModule.forRootAsync() is also available. You can supply the usual imports, inject and useFactory parameters as usual.  info Please note: If you intend to use multiple enhancers at the same time (e.g. initialize the CLS context in a middleware and then set some additional CLS variables in an interceptor), be aware that the only the first one in the chain will set the Request ID.  ","version":"Next","tagName":"h2"},{"title":"forFeature(Async)​","type":1,"pageTitle":"Module Options","url":"/nestjs-cls/api/module-options#forfeatureasync","content":" The ClsModule.forFeature() method can be used to register a Proxy Providers. The Sync method only accepts Class Proxy providers.  The ClsModule.forFeatureAsync() method accepts either ClsModuleProxyClassProviderOptions or ClsModuleProxyFactoryProviderOptions that both accept these options:  provide?:any Custom injection token to use for the provider. In case of a class provider, this parameter is optional, as the class reference passed to useClass will be used by default. imports?any[] Optional list of imported modules that export the providers which are required for the provider. extraProviders?:Provider[] Optional list of additional providers that should be available to the Proxy. Useful for passing configuration from a parent dynamic module.  The ClsModuleProxyClassProviderOptions interface further accepts:  useClass:Type The target class that will be used by this Proxy Provider. Make sure it is decorated with @InjectableProxy.  The ClsModuleProxyFactoryProviderOptions interface further accepts:  inject:any[] An array of injection tokens for providers used in the useFactory. useFactory:(...args: any[]) =&gt; any Factory function that accepts an array of providers in the order of the according tokens in the inject array. Returns (or resolves with) an object (or a function) that will be used by this Proxy Provider. type?:'function' | 'object' Whether the Proxy Provider should be a function or an object. Defaults to 'object'. See Caveats for more information.  ","version":"Next","tagName":"h2"},{"title":"Middleware & Enhancer options​","type":1,"pageTitle":"Module Options","url":"/nestjs-cls/api/module-options#middleware--enhancer-options","content":" All of the Cls{Middleware,Guard,Interceptor}Options take the following parameters (either in ClsModuleOptions or directly when instantiating them manually):  mount?:boolean (default false) Whether to automatically mount the middleware/guard/interceptor to every route (not applicable when instantiating them manually) generateId?:boolean (default false) Whether to automatically generate a request ID. It will be available under the CLS_ID key. idGenerator?:(req: Request) =&gt; string | Promise&lt;string&gt; idGenerator?:(ctx: ExecutionContext) =&gt; string | Promise&lt;string&gt; An optional function for generating the request ID. It takes the Request object (or the ExecutionContext in case of a Guard or Interceptor) as an argument and (synchronously or asynchronously) returns a string. The default implementation uses Math.random() to generate a string of 8 characters. setup?:(cls: ClsService, req: Request) =&gt; void | Promise&lt;void&gt;; setup?:(cls: ClsService, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;; Function that executes after the CLS context had been initialised. It can be used to put additional variables in the CLS context. resolveProxyProviders?:boolean (default true) Whether to automatically resolve Proxy Providers in the enhancer (if any are registered). initializePlugins?:boolean (default true) Whether to run the onClsInit hook for plugins as a part of the CLS context registration (runs before resolveProxyProviders just after setup).  The ClsMiddlewareOptions additionally takes the following parameters:  saveReq?:boolean (default true) Whether to store the Request object to the context. It will be available under the CLS_REQ key. saveRes?:boolean (default false) Whether to store the Response object to the context. It will be available under the CLS_RES key useEnterWith?:boolean (default false) Set to true to set up the context using a call to AsyncLocalStorage#enterWith instead of wrapping the next() call with the safer AsyncLocalStorage#run. Most of the time this should not be necessary, but some frameworks are known to lose the context with run. ","version":"Next","tagName":"h2"},{"title":"Compatibility","type":0,"sectionRef":"#","url":"/nestjs-cls/considerations/compatibility","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"REST​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#rest","content":" This package is compatible with Nest-supported REST controllers and the preferred way is to use the ClsMiddleware with the mount option set to true.  Tested with:  ✔ Express✔ Fastify  Known issues:  In case API versioning is used, the automatic mounting of the ClsMiddleware does not work and it needs to be mounted manually. See issue #67 for details.Some existing Express middlewares may cause context loss, if that happens, mount the ClsMiddleware manually after those offending ones (#50)  ","version":"Next","tagName":"h2"},{"title":"GraphQL​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#graphql","content":" Using an interceptor or a guard may result in that enhancer triggering multiple times in case there are multiple queries in the GQL request.  Due to this, you should ensure that any operation on the CLS store within enhancers is idempotent. This includes the setup function. Therefore, it is advised to use the ClsService#setIfUndefined() method.  Tested with:  ✔ Apollo (Express)✔ Mercurius (Fastify)  ","version":"Next","tagName":"h2"},{"title":"@nestjs/graphql >= 10​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#nestjsgraphql--10","content":" Since v10, Nest's GraphQL resolvers are compatible with this package and the preferred way to initialize the CLS context is use the ClsMiddleware with the mount option.  ","version":"Next","tagName":"h3"},{"title":"@nestjs/graphql < 10​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#nestjsgraphql--10-1","content":" For older versions of graphql, the ClsMiddleware needs to be mounted manually with app.use(...) in order to correctly set up the context for resolvers. Additionally, you have to pass useEnterWith: true to the ClsMiddleware options, because the context gets lost otherwise due to an issue with CLS and Apollo (sadly, the same is true for Mercurius). This method is functionally identical to just using the ClsGuard.  Alternatively, you can use the ClsInterceptor, which uses the safer AsyncLocalStorage#run (thanks to andreialecu), but remember that using it makes CLS unavailable in Guards.  ","version":"Next","tagName":"h3"},{"title":"Others​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#others","content":" Use the ClsGuard or ClsInterceptor to set up context with any other platform.  There are no explicit test for other transports, so I can't guarantee it will work with your platform of choice, but there's nothing that would indicate otherwise.  If you decide to try this package with a platform that is not listed here, please let me know so I can add the compatibility notice.  Below are listed transports with which it is confirmed to work:  ","version":"Next","tagName":"h2"},{"title":"Websockets​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#websockets","content":" Websocket Gateways don't respect globally bound enhancers, therefore it is required to bind the ClsGuard or ClsInterceptor manually on the WebsocketGateway. Special care is also needed for the handleConnection method (See #8) ","version":"Next","tagName":"h3"},{"title":"Breaking out of DI","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/breaking-out-of-di","content":"Breaking out of DI While this package aims to be compatible with NestJS's Dependency Injection, it is also possible to access the CLS context outside of it. For that, it provides the static ClsServiceManager class that exposes the getClsService() method which can be used to retrieve the context outside of Nest's injection context (e.g. in top-level functions) function helper() { const cls = ClsServiceManager.getClsService(); // you now have access to the shared storage console.log(cls.getId()); } caution Please note: Only use this feature where absolutely necessary. Using this technique instead of dependency injection will make it difficult to mock the ClsService and your code will become harder to test.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Migration guide","type":0,"sectionRef":"#","url":"/nestjs-cls/migration-guide","content":"Migration guide In case you're upgrading to a new major version of this library, follow the according migration guide.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Request ID","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/request-id","content":"Request ID Because of a shared storage, CLS is an ideal tool for tracking request (correlation) IDs for the purpose of logging. This package provides an option to automatically generate request IDs in the middleware/guard/interceptor, if you pass { generateId: true } to its options. By default, the generated ID is a string based on Math.random(), but you can provide a custom function in the idGenerator option. This function receives the Request (or ExecutionContext in case a ClsGuard is used) as the first parameter, which can be used in the generation process and should return (or resolve with) a string ID that will be stored in the CLS for later use. Below is an example of retrieving the request ID from the request header with a fallback to an autogenerated one. ClsModule.forRoot({ middleware: { mount: true, generateId: true, idGenerator: (req: Request) =&gt; req.headers['X-Request-Id'] ?? uuid(); } }) The ID is stored under the CLS_ID constant in the context. The ClsService provides a shorthand method getId to quickly retrieve it anywhere. It can be for example used in a custom logger: my.logger.ts @Injectable() class MyLogger { constructor(private readonly cls: ClsService) {} log(message: string) { console.log(`&lt;${this.cls.getId()}&gt; ${message}`); } } Calling this from anywhere within a CLS context results in retrieving the ID: my.service.ts @Injectable() class MyService { constructor(private readonly logger: MyLogger); hello() { this.logger.log('Hello'); // -&gt; logs for ex.: &quot;&lt;44c2d8ff-49a6-4244-869f-75a2df11517a&gt; Hello&quot; } } ","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"How it works","type":0,"sectionRef":"#","url":"/nestjs-cls/introduction/how-it-works","content":"How it works Continuation-local storage provides a common space for storing and retrieving data throughout the life of a function/callback call chain. In NestJS, this allows for sharing request data across the lifetime of a single request - without the need for request-scoped providers. It also makes it easy to track and log request ids throughout the whole application. To make CLS work, it is required to set up the CLS context first. This is done by calling cls.run() (or cls.enter(), see Security considerations for more info) somewhere in the app. Once that is set up, anything that is called within the same callback chain has access to the same storage with cls.set() and cls.get().","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Type safety and type inference","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Type-safe ClsService​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#type-safe-clsservice","content":" It is possible to specify a custom interface for the ClsService and get proper typing and automatic type inference when retrieving or setting values. This works even for nested objects using a dot notation.  To create a typed CLS Store, start by creating an interface that extends ClsStore.  export interface MyClsStore extends ClsStore { tenantId: string; user: { id: number; authorized: boolean; }; }   ","version":"Next","tagName":"h2"},{"title":"Using a type parameter​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#using-a-type-parameter","content":" Then you can inject the ClsService with a type parameter ClsService&lt;MyClsStore&gt; to make use of the safe typing.  export class MyService { constructor(private readonly cls: ClsService&lt;MyClsStore&gt;) {} doTheThing() { // a boolean type will be enforced here this.cls.set('user.authorized', true); // tenantId will be inferred as a string const tenantId = this.cls.get('tenantId'); // userId will be inferred as a number const userId = this.cls.get('user.id'); // user will be inferred as { id: number, authorized: boolean } const user = this.cls.get('user'); // you'll even get intellisense for the keys, because the type // will be inferred as: // symbol | 'tenantId˙ | 'user' | 'user.id' | 'user.authorized' // alternatively, since the `get` method returns the whole store // when called without arguments, you can use object destructuring const { tenantId, user } = this.cls.get(); // accessing a nonexistent property will result in a type error const notExist = this.cls.get('user.name'); } }   ","version":"Next","tagName":"h3"},{"title":"Using Typescript module augmentation​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#using-typescript-module-augmentation","content":" Alternatively, if you feel like using ClsService&lt;MyClsStore&gt; everywhere is tedious, you can instead globally augment the ClsStore interface.  Now you don't need to specify the type parameter on ClsService to still get the string typing.  declare module 'nestjs-cls' { interface ClsStore { tenantId: string; user: { id: number; authorized: boolean; }; } }   ","version":"Next","tagName":"h3"},{"title":"Using a custom provider​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#using-a-custom-provider","content":" For even more transparent approach without augmenting the declaration, you can create a typed ClsService by extending it and creating a custom provider out of it:  export class MyClsService extends ClsService&lt;MyClsStore&gt; {} @Module({ imports: [ClsModule.forFeature()], providers: [ { provide: MyClsService, useExisting: ClsService, }, ], exports: [MyClsService], }) class MyClsModule {}   Now you can inject MyClsService as an alias for ClsService&lt;MyClsStore&gt; without &quot;polluting&quot; the global type space.  ","version":"Next","tagName":"h3"},{"title":"Terminal Type​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#terminal-type","content":" It can happen, that the object you want to store in the context is too complex, or contains cyclic references.  In that case, typescript might complain that type instantiation is too deep, possibly infinite. That is due to the fact that it tries to generate all possible paths inside the ClsStore. If that's the case, you can use the Terminal type to stop generating the paths for a certain subtree:  interface ClsStore { tenantId: string; user: Terminal&lt;{ id: number; authorized: boolean; }&gt;; }   This will only generate the paths tenantId | user and won't allow directly accessing nested keys (like cls.get('user.id'), but you'll still get fully typing for things like const { id } = cls.get('user')). See issue #22 for more details. ","version":"Next","tagName":"h2"},{"title":"Usage outside of web request","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/usage-outside-of-web-request","content":"Usage outside of web request Sometimes, a part of the app that relies on the CLS storage might need to be called outside of the context of a web request - for example, in a Cron job, while consuming a Queue, during the application bootstrap or in CLI apps. In such cases, there are no enhancers that can be bound to the handler to set up the context. Therefore, you as the the developer are responsible for wrapping the execution with ClsService#run, or using the @UseCls decorator. In any case, if any following code depends on some context variables, these need to be set up manually. @Injectable() export class CronController { constructor( private readonly someService: SomeService, private readonly cls: ClsService, ); @Cron('45 * * * * *') async handleCronExample1() { // either explicitly wrap the function body with // a call to `ClsService#run` ... await this.cls.run(async () =&gt; { this.cls.set('mode', 'cron'); await this.someService.doTheThing(); }); } @Cron('90 * * * * *') // ... or use the convenience decorator which // does the wrapping for you seamlessly. @UseCls({ setup: (cls) =&gt; { cls.set('mode', 'cron'); }, }) async handleCronExample2() { await this.someService.doTheThing(); } } caution Special care must be taken in case you're using Proxy Providers.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"v2.x → v3.x","type":0,"sectionRef":"#","url":"/nestjs-cls/migration-guide/v2x-v3x","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Root registration method renamed​","type":1,"pageTitle":"v2.x → v3.x","url":"/nestjs-cls/migration-guide/v2x-v3x#root-registration-method-renamed","content":" The root registration method was renamed from register (resp. registerAsync) to forRoot (resp. forRootAsync) to align with the convention.  - ClsModule.register({ + ClsModule.forRoot({ middleware: { mount: true }, }),   ","version":"Next","tagName":"h2"},{"title":"Namespace support dropped​","type":1,"pageTitle":"v2.x → v3.x","url":"/nestjs-cls/migration-guide/v2x-v3x#namespace-support-dropped","content":" Namespace injection support with forFeature was dropped entirely, and now that method is used to register Proxy Providers. If you still have a use case for namespaces, you can create a namespaced ClsService and use a custom provider to inject it. Example:  class MyContextService extends ClsService&lt;MyStore&gt; {} const myContextService = new MyContextService(new AsyncLocalStorage()); // [...] providers: [ { provide: MyContextService, useValue: myContextService, }, ];  ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/nestjs-cls/introduction/installation","content":"Installation Install as any other NPM package using your favorite package manager. npmyarnpnpm npm install nestjs-cls info This module requires additional peer deps, like the @nestjs/core and @nestjs/common libraries, but it is assumed those are already installed.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Plugins","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"Plugins","url":"/nestjs-cls/plugins#usage","content":" To use a plugin, pass it to the forRoot method of the ClsModule:  ClsModule.forRoot({ plugins: [new MyPlugin()], });   ","version":"Next","tagName":"h2"},{"title":"Available plugins​","type":1,"pageTitle":"Plugins","url":"/nestjs-cls/plugins#available-plugins","content":" For a list of plugins managed by the author of nestjs-cls, see the Available Plugins page.  ","version":"Next","tagName":"h2"},{"title":"Creating a plugin​","type":1,"pageTitle":"Plugins","url":"/nestjs-cls/plugins#creating-a-plugin","content":" To create a custom plugin, see the Plugin API reference. ","version":"Next","tagName":"h2"},{"title":"Available Plugins","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/available-plugins","content":"Available Plugins This section lists all plugins that are maintained by the author of nestjs-cls. They are all published under the @nestjs-cls scope and are kept up to date with any changes to the library. Transactional","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"v3.x → v4.x","type":0,"sectionRef":"#","url":"/nestjs-cls/migration-guide/v3x-v4x","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Changed base type of Proxy Providers​","type":1,"pageTitle":"v3.x → v4.x","url":"/nestjs-cls/migration-guide/v3x-v4x#changed-base-type-of-proxy-providers","content":" The default underlying value of Proxy Providers was changed to {}. This means that the typeof operator will now return 'object', which is more intuitive. (Link to original discussion)  The use-case of using a Proxy Provider as a function is still supported, but now requires the type option to be set to 'function'.  ClsModule.forFeature({ provide: 'class-proxy', useClass: SomeClass, }); ClsModule.forFeature({ provide: 'function-proxy', useFactory: () =&gt; someFunction, type: 'function', });   @Injectable() class SomeService { constructor( @Inject('class-proxy') private readonly someClass: SomeClass, @Inject('function-proxy') private readonly functionProvider: () =&gt; void, ) { console.log(typeof this.someClass); // 'object' console.log(typeof this.functionProvider); // 'function' } }   ","version":"Next","tagName":"h2"},{"title":"Changed default of ifNested option​","type":1,"pageTitle":"v3.x → v4.x","url":"/nestjs-cls/migration-guide/v3x-v4x#changed-default-of-ifnested-option","content":" The default of the ifNested option was changed from override to inherit, which more closely aligns with most real-world use-cases.  If you used the ClsService#run method without explicitly setting the ifNested option, you should check if the new default behavior is compatible with your use-case and adjust accordingly.  this.cls.run( { ifNested: 'override' }, () =&gt; { // ... rest of the code }, );   ","version":"Next","tagName":"h2"},{"title":"Changed default of resolveProxyProviders in UseCls decorator​","type":1,"pageTitle":"v3.x → v4.x","url":"/nestjs-cls/migration-guide/v3x-v4x#changed-default-of-resolveproxyproviders-in-usecls-decorator","content":" This value was undocumented in v3, but the default was false. It was changed to true in v4 to align with the default behavior of other enhancers.  This change should not affect most use-cases, because you either don't use Proxy Providers at all, or you use them and therefore had to set it to true anyway. The only case where this might be a breaking change is if you used the @UseCls in a module where you explicitly did not want to resolve Proxy Providers and therefore did not import their dependencies. In that case, you should set the resolveProxyProviders option to false in the decorator. ","version":"Next","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/nestjs-cls/introduction/quick-start","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Background​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#background","content":" This library exposes a dynamic ClsModule which exposes the injectable ClsService and provides means to setting up and interacting with the CLS context.  The CLS context is a storage that wraps around a chain of function calls. It can be accessed anywhere during the lifecycle of such chain via the ClsService.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#example","content":" Below is an example of using this library to store the client's IP address in an interceptor and retrieving it in a service without explicitly passing it along.  note This example assumes you are using HTTP and therefore can use middleware. For usage with non-HTTP transports, see Setting up CLS context.  ","version":"Next","tagName":"h2"},{"title":"Register the ClsModule​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#register-the-clsmodule","content":" Register the ClsModule and automatically mount the ClsMiddleware which wraps the entire request in a shared CLS context on all routes.  app.module.ts @Module({ imports: [ ClsModule.forRoot({ global: true, middleware: { mount: true }, }), ], providers: [AppService], controllers: [AppController], }) export class AppModule {}   ","version":"Next","tagName":"h3"},{"title":"Create IP-address interceptor​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#create-ip-address-interceptor","content":" Create an interceptor that  injects the ClsService to get access to the current shared CLS context,extract the users's IP address from the request and stores it into the CLS context,  user-ip.interceptor.ts @Injectable() export class UserIpInterceptor implements NestInterceptor { constructor(private readonly cls: ClsService) {} intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { const request = context.switchToHttp().getRequest(); const userIp = request.connection.remoteAddress; this.cls.set('ip', userIp); return next.handle(); } }   ","version":"Next","tagName":"h3"},{"title":"Mount interceptor to controller​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#mount-interceptor-to-controller","content":" By mounting the UserIpInterceptor on the controller, it gets access to the same shared CLS context that the ClsMiddleware set up.  Of course, we could also bind the interceptor globally with APP_INTERCEPTOR.  app.controller.ts @UseInterceptors(UserIpInterceptor) @Injectable() export class AppController { constructor(private readonly appService: AppService) {} @Get('/hello') hello() { return this.appService.sayHello(); } }   ","version":"Next","tagName":"h3"},{"title":"Access CLS context in service​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#access-cls-context-in-service","content":" In the AppService, we can retrieve the user's IP from the CLS context without explicitly passing in anything, and without making the AppService request-scoped!  app.service.ts @Injectable() export class AppService { constructor(private readonly cls: ClsService) {} sayHello() { const userIp = this.cls.get('ip'); return 'Hello ' + userIp + '!'; } }   ","version":"Next","tagName":"h3"},{"title":"That's it​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#thats-it","content":" This is pretty much all there is to it. This library further provides more quality-of-life features, so read on!  info If your use-case is really simple, you can instead consider creating a custom implementation with AsyncLocalStorage. Limiting the number of dependencies in your application is always a good idea! ","version":"Next","tagName":"h3"},{"title":"Knex adapter","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/available-plugins/transactional/knex-adapter","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Knex adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/knex-adapter#installation","content":" npmyarnpnpm npm install @nestjs-cls/transactional-adapter-knex   ","version":"Next","tagName":"h2"},{"title":"Registration​","type":1,"pageTitle":"Knex adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/knex-adapter#registration","content":" ClsModule.forRoot({ plugins: [ new ClsPluginTransactional({ imports: [ // module in which the Knex is provided KnexModule ], adapter: new TransactionalAdapterKnex({ // the injection token of the Knex client knexInstanceToken: KNEX, }), }), ], }),   ","version":"Next","tagName":"h2"},{"title":"Typing & usage​","type":1,"pageTitle":"Knex adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/knex-adapter#typing--usage","content":" The tx property on the TransactionHost&lt;TransactionalAdapterKnex&gt; is typed as Knex.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Knex adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/knex-adapter#example","content":" user.service.ts @Injectable() class UserService { constructor(private readonly userRepository: UserRepository) {} @Transactional() async runTransaction() { // both methods are executed in the same transaction const user = await this.userRepository.createUser('John'); const foundUser = await this.userRepository.getUserById(r1.id); assert(foundUser.id === user.id); } }   user.repository.ts @Injectable() class UserRepository { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterKnex&gt;, ) {} async getUserById(id: number) { // txHost.tx is typed as Knex return this.txHost.tx('user').where({ id }).first(); } async createUser(name: string) { return this.txHost .tx('user') .insert({ name: name, email: `${name}@email.com` }) .returning('*'); } }  ","version":"Next","tagName":"h2"},{"title":"Pg-promise adapter","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/available-plugins/transactional/pg-promise-adapter","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Pg-promise adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/pg-promise-adapter#installation","content":" npmyarnpnpm npm install @nestjs-cls/transactional-adapter-pg-promise   ","version":"Next","tagName":"h2"},{"title":"Registration​","type":1,"pageTitle":"Pg-promise adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/pg-promise-adapter#registration","content":" import { txMode } from 'pg-promise' ClsModule.forRoot({ plugins: [ new ClsPluginTransactional({ imports: [ // module in which the database instance is provided DbModule ], adapter: new TransactionalAdapterPgPromise({ // the injection token of the database instance dbInstanceToken: DB, // default transaction options (optional) defaultTxOptions: { mode: new txMode.TransactionMode({ tiLevel: txMode.isolationLevel.serializable }) } }), }), ], }),   ","version":"Next","tagName":"h2"},{"title":"Typing & usage​","type":1,"pageTitle":"Pg-promise adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/pg-promise-adapter#typing--usage","content":" The tx property on the TransactionHost&lt;TransactionalAdapterPgPromise&gt; is typed as Database.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Pg-promise adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/pg-promise-adapter#example","content":" user.service.ts @Injectable() class UserService { constructor(private readonly userRepository: UserRepository) {} @Transactional() async runTransaction() { // both methods are executed in the same transaction const user = await this.userRepository.createUser( 'John', 'john@acme.com', ); const foundUser = await this.userRepository.getUserById(r1.id); assert(foundUser.id === user.id); } }   user.repository.ts @Injectable() class UserRepository { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterPgPromise&gt;, ) {} async getUserById(id: number) { // txHost.tx is typed as Database return this.txHost.tx.one(`SELECT * FROM user WHERE id = $1`, [id]); } async createUser(name: string, email: string) { return this.txHost.tx.none( `INSERT INTO user (name, email) VALUES ($1, $2)`, [name, email], ); } }  ","version":"Next","tagName":"h2"},{"title":"TypeORM adapter","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/available-plugins/transactional/typeorm-adapter","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"TypeORM adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/typeorm-adapter#installation","content":" npmyarnpnpm npm install @nestjs-cls/transactional-adapter-typeorm   important Please note that due to the deliberate choice to not monkey-patch any underlying library, the only way to propagate the transaction using this adapter is by using the EntityManager. There is no transactional support for working directly with repositories without getting them through the (transactional) EntityManager For a more fully-featured solution for TypeORM, see the typeorm-transactional community package.  ","version":"Next","tagName":"h2"},{"title":"Registration​","type":1,"pageTitle":"TypeORM adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/typeorm-adapter#registration","content":"  ClsModule.forRoot({ plugins: [ new ClsPluginTransactional({ imports: [ // module in which the database instance is provided TypeOrmModule ], adapter: new TransactionalAdapterTypeOrm({ // the injection token of the database instance dataSourceToken: DataSource, }), }), ], }),   note When using with @nestjs/typeorm, the data source token needs to be retrieved with the getDataSourceToken function, that can be optionally provided with a custom connection name. import { getDataSourceToken } from '@nestjs/typeorm'; // ... dataSourceToken: getDataSourceToken(),   ","version":"Next","tagName":"h2"},{"title":"Typing & usage​","type":1,"pageTitle":"TypeORM adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/typeorm-adapter#typing--usage","content":" The tx property on the TransactionHost&lt;TransactionalAdapterTypeOrm&gt; is typed as EntityManager.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"TypeORM adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/typeorm-adapter#example","content":" user.service.ts @Injectable() class UserService { constructor(private readonly userRepository: UserRepository) {} @Transactional() async runTransaction() { // both methods are executed in the same transaction const user = await this.userRepository.createUser('John'); const foundUser = await this.userRepository.getUserById(r1.id); assert(foundUser.id === user.id); } }   user.repository.ts @Injectable() class UserRepository { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterTypeOrm&gt;, ) {} async getUserById(id: number) { // txHost.tx is typed as EntityManager return await this.txHost.tx.getRepository(User).findOneBy({ id }); } async createUser(name: string, email: string) { return await this.txHost.tx.getRepository(User).save({ name, email: `${name}@email.com`, }); } }  ","version":"Next","tagName":"h2"},{"title":"Proxy Providers","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/proxy-providers","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Class Proxy Providers​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#class-proxy-providers","content":" These providers look like your regular class providers, with the exception that is the @InjectableProxy() decorator to make them easily distinguishable.  @InjectableProxy() export class User { id: number; role: string; }   To register the proxy provider, use the ClsModule.forFeature() registration, which exposes it an injectable provider in the parent module.  ClsModule.forFeature(User);   It can be then injected using the class name.  However, what will be actually injected is not the instance of the class, but rather the Proxy which redirects all access to an unique instance stored in the CLS context.  ","version":"Next","tagName":"h2"},{"title":"Populate in an enhancer​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#populate-in-an-enhancer","content":" A Class provider defined in this way will be empty upon creation, so we must assign context values to it somewhere. One place to do it is an interceptor  @Injectable() export class UserInterceptor implements NestInterceptor { // we can inject the proxy here constructor(private readonly user: User) {} intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { const request = context.switchToHttp().getRequest(); // and assign or change values as it was a normal object this.user.id = request.user.id; this.user.role = 'admin'; return next.handle(); } }   ","version":"Next","tagName":"h3"},{"title":"Self-populating Proxy Provider​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#self-populating-proxy-provider","content":" It is also possible to inject other providers into the Proxy Provider to avoid having to do this in a separate component.  For the convenience, the CLS_REQ and CLS_RES are also made into Proxy Providers and are exported from the ClsModule.  @InjectableProxy() export class UserWithRole { id: number; role: string; constructor( @Inject(CLS_REQ) request: Request, roleService: RoleService, ) { this.id = request.user.id; this.role = roleService.getForId(request.user.id); } }   If you need to inject a provider from an external module, use the ClsModule.forFeatureAsync() registration to import the containing module.  ClsModule.forFeatureAsync({ // make RoleService available to the Proxy provider import: [RoleModule], useClass: UserWithRole, });   tip Using @Inject(CLS_REQ), you can entirely replace @Inject(REQUEST) in REQUEST-SCOPED providers to turn them into CLS-enabled singletons without changing the implementation.  ","version":"Next","tagName":"h3"},{"title":"Factory Proxy Providers​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#factory-proxy-providers","content":" Like your normal factory providers, Proxy factory providers look familiar.  They can be only registered using the ClsModule.forFeatureAsync() method.  Here's an example of a hypothetical factory provider that dynamically resolves to a specific tenant database connection:  ClsModule.forFeatureAsync({ provide: TENANT_CONNECTION, import: [DatabaseConnectionModule], inject: [CLS_REQ, DatabaseConnectionService], useFactory: async (req: Request, dbService: DatabaseConnectionService) =&gt; { const tenantId = req.params['tenantId']; const connection = await dbService.getTenantConnection(tenantId); return connection; }, global: true, // make the TENANT_CONNECTION available for injection globally });   Again, the factory will be called on each request and the result will be stored in the CLS context. The TENANT_CONNECTION provider, however, will still be a singleton and will not affect the scope of whatever it is injected into.  In the service, it can be injected using the provide token as usual:  @Injectable() class DogsService { constructor( @Inject(TENANT_CONNECTION) private readonly connection: TenantConnection, ) {} getAll() { return this.connection.dogs.getAll(); } }   ","version":"Next","tagName":"h2"},{"title":"Caveats​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#caveats","content":" ","version":"Next","tagName":"h2"},{"title":"No primitive values​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#no-primitive-values","content":" Proxy Factory providers cannot return a primitive value. This is because the provider itself is the Proxy and it only delegates access once a property or a method is called on it (or if it itself is called in case the factory returns a function).  ","version":"Next","tagName":"h3"},{"title":"function Proxies must be explicitly enabled​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#function-proxies-must-be-explicitly-enabled","content":" In order to support injecting proxies of functions, the underlying proxy target must be a function, too, in order to be able to implement the &quot;apply&quot; trap. However, this information cannot be extracted from the factory function itself, so if your factory returns a function, you must explicitly set the type property to function in the provider definition.  { provide: SOME_FUNCTION, useFactory: () =&gt; { return () =&gt; { // do something }; }, type: 'function', }   note In versions prior to v4.0, calling typeof on an instance of a Proxy provider always returned function, regardless of the value it holds. This is no longer the case. Please see Issue #82  ","version":"Next","tagName":"h3"},{"title":"Delayed resolution of Proxy Providers​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#delayed-resolution-of-proxy-providers","content":" By default, proxy providers are resolved as soon as the setup function in an enhancer (middleware/guard/interceptor) finishes. For some use cases, it might be required that the resolution is delayed until some later point in the request lifecycle once more information is present in the CLS .  To achieve that, set resolveProxyProviders to false in the enhancer options and call ClsService#resolveProxyProviders() manually at any time.  ClsModule.forRoot({ middleware: { resolveProxyProviders: false, }, });   ","version":"Next","tagName":"h2"},{"title":"Outside web request​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#outside-web-request","content":" This is also necessary outside the context of web request, otherwise all access to an injected Proxy Provider will return undefined.  With cls.run()​  If you set up the context with cls.run() to wrap any subsequent code thar relies on Proxy Providers.  @Injectable() export class CronController { constructor( private readonly someService: SomeService, private readonly cls: ClsService, ); @Cron('45 * * * * *') async handleCron() { await this.cls.run(async () =&gt; { // prepare the context this.cls.set('some-key', 'some-value'); // trigger Proxy Provider resolution await this.cls.resolveProxyProviders(); await this.someService.doTheThing(); }); } }   With @UseCls()​  Since the @UseCls() decorator wraps the function body with cls.run() automatically, you can use the setup function to prepare the context.  The Proxy Providers will be resolved after the setup phase.  @Injectable() export class CronController { constructor(private readonly someService: SomeService); @Cron('45 * * * * *') @UseCls({ setup: (cls) =&gt; { cls.set('some-key', 'some-value'); }, }) async handleCron() { await this.someService.doTheThing(); } }  ","version":"Next","tagName":"h3"},{"title":"Kysely adapter","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/available-plugins/transactional/kysely-adapter","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Kysely adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/kysely-adapter#installation","content":" npmyarnpnpm npm install @nestjs-cls/transactional-adapter-kysely   ","version":"Next","tagName":"h2"},{"title":"Registration​","type":1,"pageTitle":"Kysely adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/kysely-adapter#registration","content":" ClsModule.forRoot({ plugins: [ new ClsPluginTransactional({ imports: [ // module in which the Kysely is provided KyselyModule ], adapter: new TransactionalAdapterKysely({ // the injection token of the Kysely client kyselyInstanceToken: KYSELY, }), }), ], }),   ","version":"Next","tagName":"h2"},{"title":"Typing & usage​","type":1,"pageTitle":"Kysely adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/kysely-adapter#typing--usage","content":" The tx property on the TransactionHost&lt;TransactionalAdapterKysely&gt; is typed as Kysely&lt;any&gt; by default. To get the full typing, you need to supply your database type as the type parameter for the TransactionalAdapterKysely when injecting it:  constructor( private readonly txHost: TransactionHost&lt; TransactionalAdapterKysely&lt;Database&gt; &gt;, ) {}   tip This may get a bit too verbose, so you you might want to create a type alias for it: type MyKyselyAdapter = TransactionalAdapterKysely&lt;Database&gt;; and then inject it with constructor( private readonly txHost: TransactionHost&lt;MyKyselyAdapter&gt;, ) {}   ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Kysely adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/kysely-adapter#example","content":" database.type.ts interface Database { user: User; } interface User { id: Generated&lt;number&gt;; name: string; email: string; }   user.service.ts @Injectable() class UserService { constructor(private readonly userRepository: UserRepository) {} @Transactional() async runTransaction() { // both methods are executed in the same transaction const user = await this.userRepository.createUser('John'); const foundUser = await this.userRepository.getUserById(r1.id); assert(foundUser.id === user.id); } }   user.repository.ts @Injectable() class UserRepository { constructor( private readonly txHost: TransactionHost&lt; TransactionalAdapterKysely&lt;Database&gt; &gt;, ) {} async getUserById(id: number) { // txHost.tx is typed as Kysely&lt;Database&gt; return this.txHost.tx .selectFrom('user') .where('id', '=', id) .selectAll() .executeTakeFirst(); } async createUser(name: string) { return this.txHost.tx .insertInto('user') .values({ name: name, email: `${name}@email.com`, }) .returningAll() .executeTakeFirstOrThrow(); } }  ","version":"Next","tagName":"h2"},{"title":"Setting up the CLS context","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Sync​","type":1,"pageTitle":"Setting up the CLS context","url":"/nestjs-cls/setting-up-cls-context#sync","content":" app.module.ts @Module({ imports: [ ClsModule.forRoot({ global: true, middleware: { mount: true, generateId: true, }, }), ], // ... }) export class AppModule {}   ","version":"Next","tagName":"h2"},{"title":"Async​","type":1,"pageTitle":"Setting up the CLS context","url":"/nestjs-cls/setting-up-cls-context#async","content":" app.module.ts @Module({ imports: [ ClsModule.forRootAsync({ global: true, inject: [IdGeneratorService] useFactory: (idGeneratorService) =&gt; ({ middleware: { mount: true, generateId: true, idGenerator: (req) =&gt; idGeneratorService.generate(req) }, }) }), ], // ... }) export class AppModule {}  ","version":"Next","tagName":"h2"},{"title":"Plugin API","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/plugin-api","content":"Plugin API warning The Plugin API is still experimental and might change in the future, you should not rely on it in production. Using any of the &quot;official&quot; plugins is safe since they are maintained by the same author. If you want to create your own plugin, you should be aware that the API might change between minor versions. A plugin is, in its core, a NestJS module with some extra options and should implement the following interface: export interface ClsPlugin { /** * The name of the plugin, used for logging and debugging */ name: string; /** * Function that is called within a Cls initializer (middleware, interceptor, guard, etc.) */ onClsInit?: (cls: ClsService) =&gt; void | Promise&lt;void&gt;; /** * A lifecycle method called when the `ClsModule` is initialized */ onModuleInit?: () =&gt; void | Promise&lt;void&gt;; /** * A lifecycle method called when the `ClsModule` is destroyed (only when shutdown hooks are enabled) */ onModuleDestroy?: () =&gt; void | Promise&lt;void&gt;; /** * An array of external modules that should be imported for the plugin to work. */ imports?: any[]; /** * An array of providers that the plugin provides. */ providers?: Provider[]; /** * An array of providers that the plugin provides that should be exported. */ exports?: any[]; } The plugin options are then mixed into a global ClsPluginModule and the exposed providers can be used for injection by other plugin-related code.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Prisma adapter","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/available-plugins/transactional/prisma-adapter","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Prisma adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/prisma-adapter#installation","content":" npmyarnpnpm npm install @nestjs-cls/transactional-adapter-prisma   ","version":"Next","tagName":"h2"},{"title":"Registration​","type":1,"pageTitle":"Prisma adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/prisma-adapter#registration","content":" ClsModule.forRoot({ plugins: [ new ClsPluginTransactional({ imports: [ // module in which the PrismaClient is provided PrismaModule ], adapter: new TransactionalAdapterPrisma({ // the injection token of the PrismaClient prismaInjectionToken: PrismaService, }), }), ], }),   important The prismaInjectionToken is the token under which an instance of PrismaClient provided. Usually, in Nest, this the custom PrismaService class which extends PrismaClient and is exported from a custom module.  ","version":"Next","tagName":"h2"},{"title":"Typing & usage​","type":1,"pageTitle":"Prisma adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/prisma-adapter#typing--usage","content":" The tx property on the TransactionHost&lt;TransactionalAdapterPrisma&gt; refers to the transactional PrismaClient instance when used in a transactional context. It is the instance that is passed to the prisma.$transaction(( tx ) =&gt; { ... }) callback.  Outside of a transactional context, it refers to the regular PrismaClient instance (but is typed as the transactional one).  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Prisma adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/prisma-adapter#example","content":" user.service.ts @Injectable() class UserService { constructor(private readonly userRepository: UserRepository) {} @Transactional() async runTransaction() { // both methods are executed in the same transaction const user = await this.userRepository.createUser('John'); const foundUser = await this.userRepository.getUserById(r1.id); assert(foundUser.id === user.id); } }   user.repository.ts @Injectable() class UserRepository { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterPrisma&gt;, ) {} async getUserById(id: number) { // txHost.tx is typed as the transactional PrismaClient return this.txHost.tx.user.findUnique({ where: { id } }); } async createUser(name: string) { return this.txHost.tx.user.create({ data: { name: name, email: `${name}@email.com` }, }); } }   ","version":"Next","tagName":"h2"},{"title":"Custom client type​","type":1,"pageTitle":"Prisma adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/prisma-adapter#custom-client-type","content":" Since 1.1.0  By default, the adapter assumes that the Prisma client is available as @prisma/client. If you have a different setup, or you use some Prisma client extensions, you can provide a custom type for the client as a generic parameter of the adapter.  TransactionalAdapterPrisma&lt;CustomPrismaClient&gt;;   This type will need to be used whenever you inject the TransactionHost or Transaction  private readonly txHost: TransactionHost&lt;TransactionalAdapterPrisma&lt;CustomPrismaClient&gt;&gt;   Which becomes pretty verbose, so it's recommended to create a custom type alias for the adapter.  important Please make sure you set up the module with the custom prisma client and not the default one, otherwise you would get a runtime error. new ClsPluginTransactional({ imports: [ // module in which the PrismaClient is provided PrismaModule ], adapter: new TransactionalAdapterPrisma({ // the injection token of the PrismaClient prismaInjectionToken: CUSTOM_PRISMA_CLIENT_TOKEN, }), }),  ","version":"Next","tagName":"h2"},{"title":"Using the ClsService Instance","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using_cls_run","content":"Using the ClsService Instance All other methods of setting up the CLS context ultimately use the ClsService#run or ClsService#enter methods. If all other attempts fail or you want to have a more fine-grained control over the CLS context, you can use ClsService instance to wrap any piece of code in a CLS context. An example is available in the Usage outside of web request section.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Creating a custom adapter","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Adapter interface​","type":1,"pageTitle":"Creating a custom adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter#adapter-interface","content":" A transactional adapter is an instance of an object implementing the following interface:  interface TransactionalAdapter&lt;TConnection, TTx, TOptions&gt; { connectionToken: any; defaultTyOptions?: Partial&lt;TOptions&gt;; optionsFactory: TransactionalOptionsAdapterFactory&lt; TConnection, TTx, TOptions &gt;; }   The connectionToken is an injection token under which the underlying database connection object is provided.  The defaultTxOptions object is the default transaction options that are used when no options are passed to the withTransaction call.  An optionFactory is a function that takes the injected connection object and returns the adapter options object of interface:  interface TransactionalAdapterOptions&lt;TTx, TOptions&gt; { wrapWithTransaction: ( options: TOptions, fn: (...args: any[]) =&gt; Promise&lt;any&gt;, setTx: (client: TTx) =&gt; void, ) =&gt; Promise&lt;any&gt;; getFallbackInstance: () =&gt; TTx; }   This object contains two methods:  wrapWithTransaction - a function that takes the method decorated with @Transactional (or a callback passed to TransactionHost#withTransaction) and wraps it with transaction handling logic. It should return a promise that resolves to the result of the decorated method. The other parameter is the adapter-specific transaction options object (which contains the transaction-specific options merged with the default ones) and the setTx function which should be called with the transaction instance to make it available in the CLS context. getFallbackInstance - when a transactional context is not available, this method is used to return a &quot;fallback&quot; instance of the transaction object. This is needed for cases when the tx property on TransactionHost is accessed outside of a transactional context.  ","version":"Next","tagName":"h2"},{"title":"Typing​","type":1,"pageTitle":"Creating a custom adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter#typing","content":" The most important (and tricky) part of creating a custom adapter is to define the typing for the transaction instance.  It is important to note that the tx property of TransactionHost must work both inside and outside of a transactional context. Therefore it should not have any methods that are specific to a transactional context, because they would be unavailable outside of it (and cause runtime errors).  For an adapter, we're going to need to define the following types:  TConnection - a type of the &quot;connection&quot; object. This can be anything that lets us create an instance of the transaction.TTx - a type of the transaction instance. This is the type of the tx property on TransactionHost.TOptions - a type for the options object that is passed to the underlying library's transaction handling method.  ","version":"Next","tagName":"h2"},{"title":"Step-by-step Guide​","type":1,"pageTitle":"Creating a custom adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter#step-by-step-guide","content":" In this guide, we'll show step-by-step how to create a custom adapter for the knex library.  ","version":"Next","tagName":"h2"},{"title":"How Knex handles transactions​","type":1,"pageTitle":"Creating a custom adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter#how-knex-handles-transactions","content":" First, let's take a look at how knex handles transactions and queries, so we can understand what we need to do to create a custom adapter for it.  import { Knex } from 'knex'; const knex = Knex({ // [...] knex init settings }); async function main() { // Knex uses the transaction method on the `knex` instance to start a new transaction. await knex.transaction( // The first parameter to the method is a callback that receives a `tx` object. async (tx) =&gt; { // Within the callback, the `tx` object refers to the same transaction instance. // This is what we'll need to store in the CLS context. await tx('users').insert({ name: 'John' }); await tx('users').insert({ name: 'Jane' }); }, // And the second parameter is the transaction options. { isolationLevel: 'serializable' }, ); // The `knex` instance itself can be used to issue queries outside of // the transactional context. This is what we'll provide as the fallback. const users = await knex('users') .where({ name: 'John' }) .orWhere({ name: 'Jane' }); }   ","version":"Next","tagName":"h3"},{"title":"Deciding the typing for the Knex adapter​","type":1,"pageTitle":"Creating a custom adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter#deciding-the-typing-for-the-knex-adapter","content":" As seen above, we'll need to define the following types:  TConnection - This can be typed as Knex itself, because it's the type of the knex instance that we'll use to start the transaction.TTx - While the type of the tx instance passed to knex.transaction is typed as Knex.Transaction, it also exposes methods that are specific to the transactional context. Therefore, we'll use the base Knex type here as well, because issuing queries is all that is really needed.TOptions - Knex provides an existing type called Knex.TransactionConfig for the transaction options, so we'll just use that.  ","version":"Next","tagName":"h3"},{"title":"Putting it all together​","type":1,"pageTitle":"Creating a custom adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter#putting-it-all-together","content":" While the adapter itself can be any object that implements the TransactionalAdapter interface, we'll create a class that implements it.  export class MyTransactionalAdapterKnex implements TransactionalAdapter&lt;Knex, Knex, Knex.TransactionConfig&gt; { // implement the property for the connection token connectionToken: any; // implement default options feature defaultTxOptions?: Partial&lt;Knex.TransactionConfig&gt;; // We can decide on a custom API for the transactional adapter. // In this example, we just pass individual parameters, but // a custom interface is usually preferred. constructor( myKnexInstanceToken: any, defaultTxOptions: Partial&lt;Knex.TransactionConfig&gt;, ) { this.connectionToken = myKnexInstanceToken; this.defaultTxOptions = defaultTxOptions; } // optionsFactory(knexInstance: Knex) { return { wrapWithTransaction: ( // the options object is the transaction-specific options merged with the default ones options: Knex.TransactionConfig, fn: (...args: any[]) =&gt; Promise&lt;any&gt;, setTx: (client: Knex) =&gt; void, ) =&gt; { // We'll use the `knex.transaction` method to start a new transaction. return knexInstance.transaction( (tx) =&gt; { // We'll call the `setTx` function with the `tx` instance // to store it in the CLS context. setTx(tx); // And then we'll call the original method. return fn(); }, // Don't forget to pass the options object, too options, ); }, // The fallback is the `knex` instance itself. getFallbackInstance: () =&gt; knexInstance, }; } }   ","version":"Next","tagName":"h3"},{"title":"Using the custom adapter​","type":1,"pageTitle":"Creating a custom adapter","url":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter#using-the-custom-adapter","content":" Like any other adapter, you just pass an instance of it to the adapter option of ClsPluginTransactional:  ClsModule.forRoot({ plugins: [ new ClsPluginTransactional({ // Don't forget to import the module which provides the knex instance imports: [KnexModule], adapter: new MyTransactionalAdapterKnex(KNEX_TOKEN, { isolationLevel: 'serializable' }), }), ], }),   When injecting the TransactionHost, type it as TransactionHost&lt;MyTransactionalAdapterKnex&gt; to get the correct typing of the tx property.  In a similar manner, use @Transactional&lt;MyTransactionalAdapterKnex&gt;() to get typing for the options object.  note The TransactionalAdapter can also implement all Lifecycle hooks if there's any setup or teardown logic required. However, being created manually outside of Nest's control, it can not inject any dependencies except for the pre-defined database connection instance via the connectionToken. ","version":"Next","tagName":"h3"},{"title":"Using a Decorator","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using-a-decorator","content":"Using a Decorator The @UseCls() decorator can be used at a method level to declaratively wrap the method with a cls.run() call. This method should only be used outside of the context of a web request. info Please keep in mind, that since the CLS context initialization can be async, the @UseCls() decorator can only be used on async function (those that return a Promise). Since there is no request, the setup function will not receive a Request object. Instead, it will receive the this context of the class instance (this also applies to the idGenerator), the ClsService reference and all the arguments passed to the decorated method. @Injectable() class SomeService { constructor( private readonly cls: ClsService, private readonly otherService: OtherService, ) {} @UseCls&lt;[string]&gt;({ generateId: true, idGenerator: function (this: SomeService) { return this.generateId(); }, setup: function (this: SomeService, cls: ClsService, value: string) { cls.set('some-key', 'some-value'); }, }) async startContextualWorkflow(value: string) { return this.otherService.doSomething(value); } private generateId() { return Math.random(); } } warning It is important to define the setup and idGenerator functions as functions, not arrow functions, so that the this context is properly bound.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Using a Middleware","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Automatically​","type":1,"pageTitle":"Using a Middleware","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware#automatically","content":" app.module.ts @Module({ imports: [ ClsModule.forRoot({ global: true, middleware: { mount: true }, }), ], // ... }) export class AppModule {}   ","version":"Next","tagName":"h2"},{"title":"Manually​","type":1,"pageTitle":"Using a Middleware","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware#manually","content":" Sometimes, you might want to only use CLS on certain routes, or you need to have more control over the order of middleware registration in combination with other middlewares.  ","version":"Next","tagName":"h2"},{"title":"In the module​","type":1,"pageTitle":"Using a Middleware","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware#in-the-module","content":" In that case, omit the mount option or set it to false and bind the ClsMiddleware manually in the module:  app.module.ts @Module({ imports: [ ClsModule.forRoot({ global: true, middleware: { mount: false }, }), ], // ... }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer.apply(ClsMiddleware).forRoutes('custom/route'); } }   ","version":"Next","tagName":"h3"},{"title":"Using app.use​","type":1,"pageTitle":"Using a Middleware","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware#using-appuse","content":" Sometimes, however, the previous method won't be enough, because the middleware could be mounted too late and you won't be able to use it in other middlewares that need to run prior to that - for example, the API versioning feature of NestJS apparently interferes with the order, see issue #67.  In that case, you can mount it directly in the bootstrap method:  main.ts function bootstrap() { const app = await NestFactory.create(AppModule); // create and mount the middleware manually here app.use( new ClsMiddleware({ /* ...settings */ }).use, ); await app.listen(3000); }   caution Please note: If you bind the middleware using app.use(), it will not respect middleware settings passed to ClsModule.forRoot(), so you will have to provide them yourself in the constructor. ","version":"Next","tagName":"h3"},{"title":"Using an Interceptor","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using-an-interceptor","content":"Using an Interceptor Another place to initiate the CLS context is an ClsInterceptor, which, unlike the ClsGuard uses AsyncLocalStorage#run method to wrap the following code, which is considered safer than enterWith. To use it, pass its configuration to the interceptor property to the ClsModule.forRoot() options: Automatically app.module.ts @Module({ imports: [ ClsModule.forRoot({ interceptor: { mount: true }, }), ], // ... }) export class AppModule {} Manually Or mount it manually as APP_INTERCEPTOR app.module.ts @Module({ imports: [ ClsModule.forRoot({ interceptor: { mount: false } }), ] providers: [ { provide: APP_INTERCEPTOR, useClass: ClsGuard, }, ], // ... }) export class AppModule {} or directly on the Controller/Resolver with: @UseInterceptors(ClsInterceptor); note Please note: Since Nest's Interceptors run after Guards, that means using this method makes CLS unavailable in Guards (and in case of REST Controllers, also in Exception Filters).","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"NestJS CLS","type":0,"sectionRef":"#","url":"/nestjs-cls/","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Use cases​","type":1,"pageTitle":"NestJS CLS","url":"/nestjs-cls/#use-cases","content":" Some common use cases that this library enables include:  Tracking the Request ID and other metadata for logging purposesKeeping track of the user throughout the whole requestMaking the dynamic Tenant database connection available everywhere in multi-tenant appsPropagating the authentication level or role to restrict access to resourcesSeamlessly propagating database transaction across services without breaking encapsulation and isolation by explicitly passing it around (Now available with the Transactional plugin)Using &quot;request&quot; context in cases where actual REQUEST-scoped providers are not supported (passport strategies, cron controllers, websocket gateways, ...)  Most of these are to some extent solvable using REQUEST-scoped providers or passing the context as a parameter, but these solutions are often clunky and come with a whole lot of other issues.  info * The name comes from the original implementation based on cls-hooked, which was since replaced by the native AsyncLocalStorage.  ","version":"Next","tagName":"h2"},{"title":"Motivation​","type":1,"pageTitle":"NestJS CLS","url":"/nestjs-cls/#motivation","content":" NestJS is an amazing framework, but in the plethora of awesome built-in features, I still missed one.  I created this library to solve a specific use case, which was limiting access to only those records which had the same TenantId as the request's user in a central manner. The repository code automatically added a WHERE clause to each query, which made sure that other developers couldn't accidentally mix tenant data (all tenants' data were held in the same database) without extra effort.  AsyncLocalStorage is still fairly new and not many people know of its existence and benefits. Here's a nice talk from NodeConf about the history. I've invested a great deal of my personal time in making the use of it as pleasant as possible.  While the use of async_hooks is sometimes criticized for making Node run slower, in my experience, the introduced overhead is negligible compared to any IO operation (like a DB or external API call). If you want fast, use a compiled language.  Also, if you use some tracing library (like otel), it most likely already uses async_hooks under the hood, so you might as well use it to your advantage.  ","version":"Next","tagName":"h2"},{"title":"Highlights​","type":1,"pageTitle":"NestJS CLS","url":"/nestjs-cls/#highlights","content":" New Version 4.0 brings support for Plugins which enable pre-built integrations with other libraries and frameworks. (See Migration guide for breaking changes).  Version 3.0 introduces Proxy Providers as an alternative to the imperative API. (Minor breaking changes were introduced, see Migration guide).  Version 2.0 brings advanced type safety and type inference. However, it requires features from typescript &gt;= 4.4 - Namely allowing symbol members in interfaces. If you can't upgrade but still want to use this library, install version 1.6.2, which lacks the typing features. ","version":"Next","tagName":"h2"},{"title":"Using a Guard","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using-a-guard","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Automatically​","type":1,"pageTitle":"Using a Guard","url":"/nestjs-cls/setting-up-cls-context/using-a-guard#automatically","content":" Use mount: true  app.module.ts @Module({ imports: [ ClsModule.forRoot({ guard: { mount: true }, }), ], // ... }) export class AppModule {}   ","version":"Next","tagName":"h2"},{"title":"Manually​","type":1,"pageTitle":"Using a Guard","url":"/nestjs-cls/setting-up-cls-context/using-a-guard#manually","content":" If you need any other guards to use the ClsService, it's preferable to mount ClsGuard manually as the first guard in the root module:  app.module.ts @Module({ imports: [ ClsModule.forRoot({ guard: { mount: false } }), ] providers: [ { provide: APP_GUARD, useClass: ClsGuard, }, ], // ... }) export class AppModule {}   or mount it directly on the Controller/Resolver with  @UseGuards(ClsGuard);   caution Please note: since the ClsGuard uses the AsyncLocalStorage#enterWith method, using the ClsGuard comes with some security considerations! ","version":"Next","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/nestjs-cls/testing","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Unit testing​","type":1,"pageTitle":"Testing","url":"/nestjs-cls/testing#unit-testing","content":" Since the ClsService and any created Proxy providers are just another injectable providers, they can be entirely mocked out in unit tests using standard techniques.  ","version":"Next","tagName":"h2"},{"title":"E2E testing​","type":1,"pageTitle":"Testing","url":"/nestjs-cls/testing#e2e-testing","content":" In E2E tests, you should use the real ClsService implementation to test the entire application in a real-world scenario. Unless you're using any plugins that require special handling, you should not need to do anything special to set up E2E tests.  ","version":"Next","tagName":"h2"},{"title":"Integration testing​","type":1,"pageTitle":"Testing","url":"/nestjs-cls/testing#integration-testing","content":" In certain integration tests involving flows that span multiple modules but not the entire application, you might still want to use the real ClsService implementation for context propagation.  In that case, you will need to wrap the context-aware piece of code with a call to ClsService#run or ClsService#runWith.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Testing","url":"/nestjs-cls/testing#example","content":" cat.service.ts @Injectable() export class CatService { constructor( private readonly cls: ClsService, private readonly catRepository: CatRepository, ) {} getCatForUser() { const userId = this.cls.get('userId'); return this.catRepository.getForUser(userId); } }   cat.service.spec.ts describe('CatService', () =&gt; { let service: CatService let cls: ClsService const mockCatRepository = createMock&lt;CatRepository&gt;() beforeEach(async () =&gt; { const module = await Test.createTestingModule({ // Set up most of the testing module as we normally would. providers: [ CatService, { provide: CatRepository useValue: mockCatRepository } ], imports: [ // Import the static version of ClsModule which only provides // the ClsService, but does not set up any enhancers // that would automatically set up the context on request. ClsModule ], }).compile() service = module.get(CatService) // Also retrieve the ClsService for later use. cls = module.get(ClsService) }) describe('getCatForUser', () =&gt; { it('retrieves cat based on user id', async () =&gt; { const expectedUserId = 42 mockCatRepository.getForUser.mockImplementationOnce( (id) =&gt; ({ userId: id }) ) // Wrap the test call in the `runWith` method // in which we can pass hand-crafted store values. const cat = await cls.runWith( // populate the store with mocked values for the test { userId: expectedUserId }, () =&gt; service.getCatForUser() ) expect(cat.userId).toEqual(expectedUserId) }) }) })  ","version":"Next","tagName":"h3"},{"title":"@nestjs-cls/transactional","type":0,"sectionRef":"#","url":"/nestjs-cls/plugins/available-plugins/transactional","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#installation","content":" npmyarnpnpm npm install @nestjs-cls/transactional   The plugin works in conjunction with various adapters that provide the actual transactional logic and types for the underlying database library, so you'll need to install one of those as well.  Adapters for the following libraries are available:  Prisma (see @nestjs-cls/transactional-adapter-prisma)Knex (see @nestjs-cls/transactional-adapter-knex)Kysely (see @nestjs-cls/transactional-adapter-knex)Pg-promise (see @nestjs-cls/transactional-adapter-pg-promise)TypeORM (see @nestjs-cls/transactional-adapter-typeorm)  Adapters will not be implemented for the following libraries (unless there is a serious demand):  Sequelize (since it already includes a built-in CLS-enabled transaction support)  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#example","content":" For this example, we'll use the prisma library and the @nestjs-cls/transactional-adapter-prisma adapter. Later, you'll learn how to create your own adapter.  Suppose we already have a PrismaModule which provides a PrismaClient instance and two other services UserService and AccountService which we'd like to make transactional.  ","version":"Next","tagName":"h2"},{"title":"Plugin registration​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#plugin-registration","content":" To add register the transactional plugin with nestjs-cls, we need to pass it to the forRoot method of the ClsModule:  app.module.ts import { ClsModule } from 'nestjs-cls'; import { ClsPluginTransactional } from '@nestjs-cls/transactional'; import { TransactionalAdapterPrisma } from '@nestjs-cls/transactional-adapter-prisma'; // ... other imports @Module({ imports: [ PrismaModule, ClsModule.forRoot({ plugins: [ new ClsPluginTransactional({ // if PrismaModule is not global, we need to make it available to the plugin imports: [PrismaModule], adapter: new TransactionalAdapterPrisma({ // each adapter has its own options, see the adapter docs for more info prismaInjectionToken: PrismaClient, }), }), ], }), ], providers: [UserService, AccountService], }) export class AppModule {}   This registers a TransactionHost provider in the global context which can be used to start a new transaction and retrieve the current transaction reference.  ","version":"Next","tagName":"h3"},{"title":"Using the TransactionHost​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#using-the-transactionhost","content":" Now that we have the plugin registered, we can use the TransactionHost to start a new transaction and retrieve the current transaction reference.  Suppose that any time we create an User, we want to create an Account for them as well and both operations must either succeed or fail. We can use the TransactionHost to start a new transaction and retrieve the current transaction reference.  The type argument on the TransactionHost&lt;Adapter&gt; makes sure that the tx property is typed correctly and the withTransaction method returns the correct type. This is ensured by the implementation of the adapter:  user.service.ts import { TransactionHost } from '@nestjs-cls/transactional'; import { TransactionalAdapterPrisma } from '@nestjs-cls/transactional-adapter-prisma'; // ... other imports @Injectable() class UserService { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterPrisma&gt;, private readonly accountService: AccountService, ) {} async createUser(name: string): Promise&lt;User&gt; { return this.txHost.withTransaction(async () =&gt; { const user = await this.txHost.tx.user.create({ data: { name } }); await this.accountService.createAccountForUser(user.id); return user; }); } }   account.service.ts import { TransactionHost } from '@nestjs-cls/transactional'; import { TransactionalAdapterPrisma } from '@nestjs-cls/transactional-adapter-prisma'; // ... other imports @Injectable() class AccountService { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterPrisma&gt;, ) {} async createAccountForUser(id: number): Promise&lt;Account&gt; { return this.txHost.tx.user.create({ data: { userId: id, number: Math.random() }, }); } }   note Notice that we never used either raw PrismaClient or the prisma.$transaction directly. This is because the adapter takes care of that for us, otherwise the transaction would not be propagated in the CLS context.  ","version":"Next","tagName":"h3"},{"title":"Using the @Transactional decorator​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#using-the-transactional-decorator","content":" The @Transactional decorator can be used to wrap a method call in the withTransaction call implicitly. This saves a lot of boilerplate code and makes the code more readable.  Using the decorator, we can change the createUser method like so without changing the behavior:  user.service.ts import { TransactionHost, Transactional } from '@nestjs-cls/transactional'; import { TransactionalAdapterPrisma } from '@nestjs-cls/transactional-adapter-prisma'; // ... other imports @Injectable() class UserService { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterPrisma&gt;, private readonly accountService: AccountService, ) {} @Transactional() async createUser(name: string): Promise&lt;User&gt; { const user = await this.txHost.tx.user.create({ data: { name } }); await this.accountService.createAccountForUser(user.id); return user; } }   ","version":"Next","tagName":"h3"},{"title":"Using the @InjectTransaction decorator​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#using-the-injecttransaction-decorator","content":" since v2.2.0  The @InjectTransaction decorator can be used to inject a Proxy Provider of the Transaction instance (the tx property of the TransactionHost) directly as a dependency.  This is useful when you don't want to inject the entire TransactionHost and only need the transaction instance itself. For example when you're migrating an existing codebase and don't want to change all database calls to use txHost.tx.  The type argument of Transaction&lt;Adapter&gt; behaves silimarly to the TransactionHost type argument, and ensures that the transaction instance is typed correctly.  account.service.ts import { InjectTransaction, Transaction, Transactional } from '@nestjs-cls/transactional'; import { TransactionalAdapterPrisma } from '@nestjs-cls/transactional-adapter-prisma'; // ... other imports @Injectable() class AccountService { constructor( @InjectTransaction() private readonly tx: Transaction&lt;TransactionalAdapterPrisma&gt;, ) {} async createAccountForUser(id: number): Promise&lt;Account&gt; { return this.tx.create({ data: { userId: id, number: Math.random() }, }); } }   important When a transaction is not active, the Transaction instance refers to the default non-transactional instance. However, if the CLS context is not active, the Transaction instance will be undefined instead, which could cause runtime errors. Therefore, this feature works reliably only when the CLS context is active prior to starting the transaction. Additionally, some adapters do not support this feature due to the nature of how transactions work in the library they implement. For these reasons, this is an opt-in feature that must be explicitly enabled with the enableTransactionProxy: true option of the ClsPluginTransactional constructor. new ClsPluginTransactional({ imports: [PrismaModule], adapter: new TransactionalAdapterPrisma({ prismaInjectionToken: PrismaClient, }), enableTransactionProxy: true, });   ","version":"Next","tagName":"h3"},{"title":"Passing transaction options​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#passing-transaction-options","content":" The both the withTransaction method and the Transactional decorator accepts an optional TransactionOptions object as the first argument. This object can be used to configure the transaction, for example to set the isolation level or the timeout.  The type of the object is provided by the adapter, so to enforce the correct type, you need to pass the adapter type argument to the TransactionHost or to the Transactional decorator.  @Transactional&lt;TransactionalAdapterPrisma&gt;({ isolationLevel: 'Serializable' }) async createUser(name: string): Promise&lt;User&gt; { const user = await this.txHost.tx.user.create({ data: { name } }); await this.accountService.createAccountForUser(user.id); return user; }   async createUser(name: string): Promise&lt;User&gt; { return this.txHost.withTransaction({ isolationLevel: 'Serializable' }, async () =&gt; { const user = await this.txHost.tx.user.create({ data: { name } }); await this.accountService.createAccountForUser(user.id); return user; }); }   ","version":"Next","tagName":"h3"},{"title":"Transaction propagation​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#transaction-propagation","content":" Similar to how the @Transactional decorator work in Spring and other similar frameworks. The @Transactional decorator and the withTransaction method accept an optional propagation option as the first parameter which can be used to configure how the transaction should be propagated.  The propagation option is controlled by the Propagation enum, which has the following values:  Required: (default) Reuse the existing transaction or create a new one if none exists. RequiresNew: Create a new transaction even if one already exists. NotSupported: Run without a transaction even if one exists. Mandatory: Reuse an existing transaction, throw an exception otherwise Never: Throw an exception if an existing transaction exists, otherwise create a new one  This parameter comes before the TransactionOptions object, if one is provided. The default behavior when a nested transaction decorator is encountered if no propagation option is provided, is to reuse the existing transaction or create a new one if none exists, which is the same as the Required propagation option.  Example:  user.service.ts @Injectable() class UserService { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterPrisma&gt;, private readonly accountService: AccountService, ) {} @Transactional( // Propagation.RequiresNew will always create a new transaction // even if one already exists. Propagation.RequiresNew, ) async createUser(name: string): Promise&lt;User&gt; { const user = await this.txHost.tx.user.create({ data: { name } }); await this.accountService.createAccountForUser(user.id); return user; } }   account.service.ts @Injectable() class AccountService { constructor( private readonly txHost: TransactionHost&lt;TransactionalAdapterPrisma&gt;, ) {} @Transactional&lt;TransactionalAdapterPrisma&gt;( // Propagation.Mandatory enforces that an existing transaction is reused, // otherwise an exception is thrown. Propagation.Mandatory, // When a propagation option is provided, // the transaction options are passed as the second parameter. { isolationLevel: 'Serializable', }, ) async createAccountForUser(id: number): Promise&lt;Account&gt; { return this.txHost.tx.user.create({ data: { userId: id, number: Math.random() }, }); } }   ","version":"Next","tagName":"h3"},{"title":"ClsPluginTransactional Interface​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#clsplugintransactional-interface","content":" The ClsPluginTransactional constructor takes an options object with the following properties:  imports: any[] An array of NestJS modules that should be imported for the plugin to work. If the dependencies are available in the global context, this is not necessary. adapter: TransactionalAdapter An instance of the adapter that should be used for the plugin. enableTransactionProxy: boolean (default: false) Whether to enable injecting the Transaction instance directly using @InjectTransaction()  ","version":"Next","tagName":"h2"},{"title":"TransactionHost Interface​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#transactionhost-interface","content":" The TransactionHost interface is the main working interface of the plugin. It provides the following API:  tx: Transaction Reference to the currently active transaction. Depending on the adapter implementation for the underlying database library, this can be either a transaction client instance, a transaction object or a transaction ID. If no transaction is active, refers to the default non-transactional client instance (or undefined transaction ID). withTransaction(callback: Promise): Promise withTransaction(options, callback): Promise withTransaction(propagation, callback): Promise withTransaction(propagation, options, callback): Promise Runs the callback in a transaction. Optionally takes Propagation and TransactionOptions as the first one or two parameters. withoutTransaction(callback): Promise Runs the callback without a transaction (even if one is active in the parent scope). isTransactionActive(): boolean Returns whether a CLS-managed transaction is active in the current scope.  ","version":"Next","tagName":"h2"},{"title":"Transactional decorator interface​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#transactional-decorator-interface","content":" The @Transactional decorator can be used to wrap a method call in the withTransaction call implicitly. It has the following call signatures:  @Transactional()@Transactional(propagation)@Transactional(options)@Transactional(propagation, options)  Or when using named connections:  @Transactional(connectionName, propagation?, options?)  ","version":"Next","tagName":"h3"},{"title":"Multiple databases​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#multiple-databases","content":" Similar to other @nestjs/&lt;orm&gt; libraries, the @nestjs-cls/transactional plugin can be used to manage transactions for multiple database connections, or even multiple database libraries altogether.  ","version":"Next","tagName":"h2"},{"title":"Registration​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#registration","content":" To use multiple connections, register multiple instances of the ClsPluginTransactional, each with an unique connectionName:  ClsModule.forRoot({ plugins: [ new ClsPluginTransactional({ connectionName: 'prisma-connection', imports: [PrismaModule], adapter: new TransactionalAdapterPrisma({ prismaInjectionToken: PrismaClient, }), }), new ClsPluginTransactional({ connectionName: 'knex-connection', imports: [KnexModule], adapter: new TransactionalAdapterKnex({ knexInstanceToken: KNEX, }), }), ], }),   This works for any number of connections and any number of database libraries.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"@nestjs-cls/transactional","url":"/nestjs-cls/plugins/available-plugins/transactional#usage","content":" To use the TransactionHost for a specific connection, you need to use @InjectTransactionHost('connectionName') decorator to inject the TransactionHost. Otherwise Nest will try to inject the default unnamed instance which will result in an injection error.  Similarly, the @InjectTransaction decorator accepts the connection name as the first argument.  @Injectable() class UserService { constructor( @InjectTransactionHost('prisma-connection') private readonly txHost: TransactionHost&lt;TransactionalAdapterPrisma&gt;, @InjectTransaction('prisma-connection') private readonly tx: Transaction&lt;TransactionalAdapterPrisma&gt;, ) {} // ... }   note @InjectTransactionHost('connectionName') is a short for @Inject(getTransactionHostToken('connectionName')). The getTransactionHostToken function is useful for when you need to mock the TransactionHost in unit tests. Similarly, @InjectTransaction('connectionName') is a short for @Inject(getTransactionToken('connectionName')).  In a similar fashion, using the @Transactional decorator requires the connectionName to be passed as the first argument.  @Transactional('prisma-connection') async createUser(name: string): Promise&lt;User&gt; { await this.accountService.createAccountForUser(user.id); return user; }  ","version":"Next","tagName":"h3"}],"options":{"indexBaseUrl":true,"id":"default"}}
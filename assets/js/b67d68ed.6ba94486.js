"use strict";(self.webpackChunknestjs_cls_docs=self.webpackChunknestjs_cls_docs||[]).push([[6623],{9719:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"plugins/plugin-api","title":"Plugin API","description":"The Plugin API is stable since v6.0.0 and should only change between major versions.","source":"@site/docs/06_plugins/02_plugin-api.md","sourceDirName":"06_plugins","slug":"/plugins/plugin-api","permalink":"/nestjs-cls/plugins/plugin-api","draft":false,"unlisted":false,"editUrl":"https://github.com/Papooch/nestjs-cls/tree/main/docs/docs/06_plugins/02_plugin-api.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"documentationSidebar","previous":{"title":"Creating a custom adapter","permalink":"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter"},"next":{"title":"Testing","permalink":"/nestjs-cls/testing/"}}');var s=t(2540),o=t(3023);const r={},l="Plugin API",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Plugin interface",id:"plugin-interface",level:2},{value:"CLS Hooks",id:"cls-hooks",level:2},{value:"Creating a plugin",id:"creating-a-plugin",level:2},{value:"Using plugin options",id:"using-plugin-options",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"plugin-api",children:"Plugin API"})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["The Plugin API is stable since ",(0,s.jsx)(n.code,{children:"v6.0.0"})," and should only change between major versions."]}),(0,s.jsx)(n.p,{children:'Any of the "official" plugins will always be kept in sync and updated to be compatible with any new version of the Plugin API.'})]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["A plugin provides a way to hook into the lifecycle of the ",(0,s.jsx)(n.code,{children:"setup"})," phase of Cls-initializers (middleware, interceptor, guard, decorator) and modify/extend the contents of CLS Store."]}),"\n",(0,s.jsxs)(n.p,{children:["Every plugin must implement the ",(0,s.jsx)(n.code,{children:"ClsPlugin"})," interface and have a ",(0,s.jsx)(n.strong,{children:"globally unique name"})," that is used to identify its components in the DI system."]}),"\n",(0,s.jsxs)(n.p,{children:["A plugin is, it its essence, just a NestJS module that can register its own providers and standard NestJS lifecycle hooks. These providers will be available in the DI system everywhere that ",(0,s.jsx)(n.code,{children:"ClsService"})," is available."]}),"\n",(0,s.jsx)(n.h2,{id:"plugin-interface",children:"Plugin interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface ClsPlugin {\n    readonly name: string;\n\n    imports?: any[];\n    providers?: Provider[];\n    exports?: any[];\n\n    onModuleInit?: () => void | Promise<void>;\n    onModuleDestroy?: () => void | Promise<void>;\n    onApplicationBootstrap?: () => void | Promise<void>;\n    onApplicationShutdown?: (signal?: string) => void | Promise<void>;\n    beforeApplicationShutdown?: (signal?: string) => void | Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cls-hooks",children:"CLS Hooks"}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned above, a plugin can register a special provider that implements the ",(0,s.jsx)(n.code,{children:"ClsPluginHooks"})," interface. This provider should be registered under the ",(0,s.jsx)(n.code,{children:"getPluginHooksToken(<pluginName>)"})," token, where ",(0,s.jsx)(n.code,{children:"pluginName"})," is the name of the plugin."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface ClsPluginHooks {\n    beforeSetup?: (\n        cls: ClsService,\n        context: ClsInitContext,\n    ) => void | Promise<void>;\n\n    afterSetup?: (\n        cls: ClsService,\n        context: ClsInitContext,\n    ) => void | Promise<void>;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This interface can contain two methods: ",(0,s.jsx)(n.code,{children:"beforeSetup"})," and ",(0,s.jsx)(n.code,{children:"afterSetup"}),". These methods are called before and after the ",(0,s.jsx)(n.code,{children:"setup"})," phase of the Cls-initializers and have access to the ",(0,s.jsx)(n.code,{children:"ClsService"})," and the ",(0,s.jsx)(n.code,{children:"ClsInitContext"})," object."]}),"\n",(0,s.jsxs)(n.p,{children:["Since the plugin cannot know which Cls-initializer is being used, it is up to the plugin to check the ",(0,s.jsx)(n.code,{children:"ClsInitContext"})," object and decide what to do. The ",(0,s.jsx)(n.code,{children:"ClsInitContext"})," will always contain the ",(0,s.jsx)(n.code,{children:"kind"})," property, with a value of either ",(0,s.jsx)(n.code,{children:"middleware"}),", ",(0,s.jsx)(n.code,{children:"interceptor"}),", ",(0,s.jsx)(n.code,{children:"guard"}),", ",(0,s.jsx)(n.code,{children:"decorator"})," or ",(0,s.jsx)(n.code,{children:"custom"}),". and other properties depending on the kind of Cls-initializer."]}),"\n",(0,s.jsx)(n.p,{children:"A plugin author should indicate in the documentation which Cls-initializers are supported by the plugin, if there are any limitations. Otherwise, the plugin should be able to work with any Cls-initializer."}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-plugin",children:"Creating a plugin"}),"\n",(0,s.jsxs)(n.p,{children:["Implementing the aforementioned interface and supplying the (optional) hooks provider is all that is needed to create a plugin. And instance of the plugin can be passed to the ",(0,s.jsx)(n.code,{children:"plugins"})," array of the ",(0,s.jsx)(n.code,{children:"ClsModule"})," options."]}),"\n",(0,s.jsxs)(n.p,{children:["However, the ",(0,s.jsx)(n.code,{children:"nestjs-cls"})," package exports a ",(0,s.jsx)(n.code,{children:"ClsPluginBase"})," class, that can be extended to easily create a plugin."]}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we will implement a plugin that extracts the ",(0,s.jsx)(n.code,{children:"user"})," property from the request and wraps it in a custom ",(0,s.jsx)(n.a,{href:"/nestjs-cls/features-and-use-cases/proxy-providers",children:"Proxy provider"})," for injection."]}),"\n",(0,s.jsx)(n.p,{children:"The plugin will work in the following way:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["First, check if the ",(0,s.jsx)(n.code,{children:"user"})," property is already set in the CLS Store. If it is, do nothing (in case the user registers multiple initializers)."]}),"\n",(0,s.jsxs)(n.li,{children:["Determine the kind of Cls-initializer that is being used and add the ",(0,s.jsx)(n.code,{children:"user"})," property to the CLS Store."]}),"\n",(0,s.jsxs)(n.li,{children:["Register a custom ",(0,s.jsx)(n.code,{children:"ClsUserHost"})," proxy provider that hosts the ",(0,s.jsx)(n.code,{children:"user"})," property for injection anywhere in the application."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Define a symbol as a key in the CLS Store\nexport const USER_CLS_SYMBOL = Symbol('user');\n\n// Define a custom proxy provider that hosts the user property\n@InjectableProxy()\nexport class ClsUserHost {\n    public readonly user: MyUserType;\n\n    constructor(private readonly cls: ClsService) {\n        this.user = this.cls.get<MyUserType>(USER_CLS_SYMBOL);\n    }\n}\n\n// To Create the plugin, extend the ClsPluginBase class\nexport class UserPlugin extends ClsPluginBase {\n    constructor() {\n        // Specify a unique name for the plugin\n        super('user-plugin');\n\n        // Register the plugin hooks using the convenience method\n        this.registerHooks({\n            useFactory: () => ({\n                afterSetup(cls, context) {\n                    // This hook will be called after the setup phase of every Cls-initializer\n                    // so we check if the user property is already set and do nothing\n                    if (cls.has(USER_CLS_SYMBOL)) {\n                        return;\n                    }\n\n                    // If the user property is not set, we check the kind of Cls-initializer\n                    switch (context.kind) {\n                        case 'middleware':\n                            cls.set(USER_CLS_SYMBOL, context.req.user);\n                            break;\n                        case 'interceptor':\n                            cls.set(\n                                USER_CLS_SYMBOL,\n                                context.ctx.switchToHttp().getRequest().user,\n                            );\n                            break;\n                        case 'guard':\n                            cls.set(\n                                USER_CLS_SYMBOL,\n                                context.ctx.switchToHttp().getRequest().user,\n                            );\n                            break;\n                        default:\n                            // If the kind is not supported (decorator or custom), we throw an error,\n                            // because there is no request.\n                            // If the user wants to use the plugin in a decorator or a custom\n                            // Cls-initializer, they should set the user property manually\n                            // in the `setup` method of the Decorator\n                            throw new Error(\n                                `Unsupported context kind: ${context.kind}`,\n                            );\n                    }\n                },\n            }),\n        });\n\n        // Register the custom Proxy provider\n        this.imports.push(ClsModule.forFeature(ClsUserHost));\n    }\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"It is also possible to expose the User itself as Proxy provider without the need of the plugin. This is only for demonstration purposes."})}),"\n",(0,s.jsx)(n.h2,{id:"using-plugin-options",children:"Using plugin options"}),"\n",(0,s.jsx)(n.p,{children:"If we wanted to customize the plugin and allow the user to be retrieved from a custom property name from the request, we could do it by adding some options to the plugin constructor."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export class UserPlugin extends ClsPluginBase {\n    // highlight-start\n    constructor(userPropertyName: string) {\n    // highlight-end\n        // Specify a unique name for the plugin\n        super('user-plugin');\n\n// [...]\n                afterSetup(cls, context) {\n\n                    switch (context.kind) {\n                        case 'middleware':\n                            // highlight-start\n                            cls.set(USER_CLS_SYMBOL, context.req[userPropertyName]);\n                            // highlight-end\n                            break;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A more advanced use-case would be to allow passing the options asynchronously. For that, we can use the ",(0,s.jsx)(n.code,{children:"imports"})," array and the ",(0,s.jsx)(n.code,{children:"inject"})," method on the ",(0,s.jsx)(n.code,{children:"this.registerHooks"})," method. An example can be found in the implementation of the existing plugins."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},3023:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(3696);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);
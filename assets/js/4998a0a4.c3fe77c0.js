"use strict";(self.webpackChunknestjs_cls_docs=self.webpackChunknestjs_cls_docs||[]).push([[9872],{6443:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var s=t(4246),i=t(1670);const r={},a="Type safety and type inference",o={id:"features-and-use-cases/type-safety-and-type-inference",title:"Type safety and type inference",description:"Since v2.0",source:"@site/docs/03_features-and-use-cases/05_type-safety-and-type-inference.md",sourceDirName:"03_features-and-use-cases",slug:"/features-and-use-cases/type-safety-and-type-inference",permalink:"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference",draft:!1,unlisted:!1,editUrl:"https://github.com/Papooch/nestjs-cls/tree/main/docs/docs/03_features-and-use-cases/05_type-safety-and-type-inference.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Usage outside of web request",permalink:"/nestjs-cls/features-and-use-cases/usage-outside-of-web-request"},next:{title:"Proxy Providers",permalink:"/nestjs-cls/features-and-use-cases/proxy-providers"}},c={},l=[{value:"Type-safe ClsService",id:"type-safe-clsservice",level:2},{value:"Using a type parameter",id:"using-a-type-parameter",level:3},{value:"Using Typescript module augmentation",id:"using-typescript-module-augmentation",level:3},{value:"Using a custom provider",id:"using-a-custom-provider",level:3},{value:"Terminal Type",id:"terminal-type",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"type-safety-and-type-inference",children:"Type safety and type inference"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"v2.0"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["By default the CLS context is untyped and allows setting and retrieving any ",(0,s.jsx)(n.code,{children:"string"})," or ",(0,s.jsx)(n.code,{children:"symbol"})," keys from the context. Some safety can be enforced by using ",(0,s.jsx)(n.code,{children:"CONSTANTS"})," instead of magic strings, but that might not be enough."]}),"\n",(0,s.jsx)(n.h2,{id:"type-safe-clsservice",children:"Type-safe ClsService"}),"\n",(0,s.jsxs)(n.p,{children:["It is possible to specify a custom interface for the ",(0,s.jsx)(n.code,{children:"ClsService"})," and get proper typing and automatic type inference when retrieving or setting values. This works even for ",(0,s.jsx)(n.em,{children:"nested objects"})," using a dot notation."]}),"\n",(0,s.jsxs)(n.p,{children:["To create a typed CLS Store, start by creating an interface that extends ",(0,s.jsx)(n.code,{children:"ClsStore"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"title=my-cls-service.interface.ts",children:"export interface MyClsStore extends ClsStore {\n    tenantId: string;\n    user: {\n        id: number;\n        authorized: boolean;\n    };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-a-type-parameter",children:"Using a type parameter"}),"\n",(0,s.jsxs)(n.p,{children:["Then you can inject the ",(0,s.jsx)(n.code,{children:"ClsService"})," with a type parameter ",(0,s.jsx)(n.code,{children:"ClsService<MyClsStore>"})," to make use of the safe typing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export class MyService {\n    // highlight-start\n    constructor(private readonly cls: ClsService<MyClsStore>) {}\n    // highlight-end\n\n    doTheThing() {\n        // a boolean type will be enforced here\n        this.cls.set('user.authorized', true);\n\n        // tenantId will be inferred as a string\n        const tenantId = this.cls.get('tenantId');\n\n        // userId will be inferred as a number\n        const userId = this.cls.get('user.id');\n\n        // user will be inferred as { id: number, authorized: boolean }\n        const user = this.cls.get('user');\n\n        // you'll even get intellisense for the keys, because the type\n        // will be inferred as:\n        // symbol | 'tenantId\u02d9 | 'user' | 'user.id' | 'user.authorized'\n\n        // alternatively, since the `get` method returns the whole store\n        // when called without arguments, you can use object destructuring\n        const { tenantId, user } = this.cls.get();\n\n        // accessing a nonexistent property will result in a type error\n        const notExist = this.cls.get('user.name');\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-typescript-module-augmentation",children:"Using Typescript module augmentation"}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, if you feel like using ",(0,s.jsx)(n.code,{children:"ClsService<MyClsStore>"})," everywhere is tedious, you can instead globally ",(0,s.jsxs)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/declaration-merging.html",children:["augment the ",(0,s.jsx)(n.code,{children:"ClsStore interface"})]}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Now you don't need to specify the type parameter on ",(0,s.jsx)(n.code,{children:"ClsService"})," to still get the string typing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"declare module 'nestjs-cls' {\n    interface ClsStore {\n        tenantId: string;\n        user: {\n            id: number;\n            authorized: boolean;\n        };\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-a-custom-provider",children:"Using a custom provider"}),"\n",(0,s.jsxs)(n.p,{children:["For even more transparent approach without augmenting the declaration, you can create a typed ",(0,s.jsx)(n.code,{children:"ClsService"})," by extending it and creating a custom provider out of it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export class MyClsService extends ClsService<MyClsStore> {}\n\n@Module({\n    imports: [ClsModule.forFeature()],\n    providers: [\n        {\n            provide: MyClsService,\n            useExisting: ClsService,\n        },\n    ],\n    exports: [MyClsService],\n})\nclass MyClsModule {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now you can inject ",(0,s.jsx)(n.code,{children:"MyClsService"})," as an alias for ",(0,s.jsx)(n.code,{children:"ClsService<MyClsStore>"}),' without "polluting" the global type space.']}),"\n",(0,s.jsxs)(n.admonition,{type:"important",children:[(0,s.jsxs)(n.p,{children:["Please note that in this case, the extended class acts only as an alternative ",(0,s.jsx)(n.em,{children:"Injection token"}),". It doesn't allow you to extend the ",(0,s.jsx)(n.code,{children:"ClsService"})," with custom methods (they wouldn't be accessible on the injected instance, because what gets injected is the original ",(0,s.jsx)(n.code,{children:"ClsService"}),")."]}),(0,s.jsxs)(n.p,{children:["If you're thinking of extending the ",(0,s.jsx)(n.code,{children:"ClsService"}),", please consider instead wrapping it in a custom provider (an adapter/facade if you will) that exposes only methods appropriate for your application and proxies calls to ",(0,s.jsx)(n.code,{children:"ClsService"}),". If you still aren't convinced, please create a feature request and explain your reasoning."]})]}),"\n",(0,s.jsx)(n.h2,{id:"terminal-type",children:"Terminal Type"}),"\n",(0,s.jsx)(n.p,{children:"It can happen, that the object you want to store in the context is too complex, or contains cyclic references."}),"\n",(0,s.jsxs)(n.p,{children:["In that case, typescript might complain that ",(0,s.jsx)(n.em,{children:"type instantiation is too deep, possibly infinite"}),". That is due to the fact that it tries to generate all possible paths inside the ",(0,s.jsx)(n.code,{children:"ClsStore"}),". If that's the case, you can use the ",(0,s.jsx)(n.code,{children:"Terminal"})," type to stop generating the paths for a certain subtree:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface ClsStore {\n    tenantId: string;\n    // highlight-start\n    user: Terminal<{\n        id: number;\n        authorized: boolean;\n    }>;\n    // highlight-end\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This will only generate the paths ",(0,s.jsx)(n.code,{children:"tenantId | user"})," and won't allow directly accessing nested keys (like ",(0,s.jsx)(n.code,{children:"cls.get('user.id')"}),", but you'll still get fully typing for things like ",(0,s.jsx)(n.code,{children:"const { id } = cls.get('user')"}),"). See issue ",(0,s.jsx)(n.a,{href:"https://github.com/Papooch/nestjs-cls/issues/22",children:"#22"})," for more details."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var s=t(7378);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunknestjs_cls_docs=self.webpackChunknestjs_cls_docs||[]).push([[2581],{8727:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var a=t(4246),i=t(1670);const s={},o="Creating a custom adapter",c={id:"plugins/available-plugins/transactional/creating-custom-adapter",title:"Creating a custom adapter",description:"If you can't find an adapter for a database library you want to use with @nestjs-cls/transactional, you can create a custom adapter. See below for a step-by-step guide.",source:"@site/docs/06_plugins/01_available-plugins/01-transactional/99-creating-custom-adapter.md",sourceDirName:"06_plugins/01_available-plugins/01-transactional",slug:"/plugins/available-plugins/transactional/creating-custom-adapter",permalink:"/nestjs-cls/plugins/available-plugins/transactional/creating-custom-adapter",draft:!1,unlisted:!1,editUrl:"https://github.com/Papooch/nestjs-cls/tree/main/docs/docs/06_plugins/01_available-plugins/01-transactional/99-creating-custom-adapter.md",tags:[],version:"current",sidebarPosition:99,frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Drizzle ORM adapter",permalink:"/nestjs-cls/plugins/available-plugins/transactional/drizzle-orm-adapter"},next:{title:"Plugin API",permalink:"/nestjs-cls/plugins/plugin-api"}},r={},l=[{value:"Adapter interface",id:"adapter-interface",level:2},{value:"Typing",id:"typing",level:2},{value:"Step-by-step Guide",id:"step-by-step-guide",level:2},{value:"How Knex handles transactions",id:"how-knex-handles-transactions",level:3},{value:"Deciding the typing for the Knex adapter",id:"deciding-the-typing-for-the-knex-adapter",level:3},{value:"Putting it all together",id:"putting-it-all-together",level:3},{value:"Using the custom adapter",id:"using-the-custom-adapter",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"creating-a-custom-adapter",children:"Creating a custom adapter"}),"\n",(0,a.jsxs)(n.p,{children:["If you can't find an adapter for a database library you want to use with ",(0,a.jsx)(n.code,{children:"@nestjs-cls/transactional"}),", you can create a custom adapter. ",(0,a.jsx)(n.a,{href:"#step-by-step-guide",children:"See below for a step-by-step guide"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"adapter-interface",children:"Adapter interface"}),"\n",(0,a.jsx)(n.p,{children:"A transactional adapter is an instance of an object implementing the following interface:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"interface TransactionalAdapter<TConnection, TTx, TOptions> {\n    connectionToken: any;\n    defaultTyOptions?: Partial<TOptions>;\n    optionsFactory: TransactionalOptionsAdapterFactory<\n        TConnection,\n        TTx,\n        TOptions\n    >;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"connectionToken"})," is an injection token under which the underlying database connection object is provided."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"defaultTxOptions"})," object is the default transaction options that are used when no options are passed to the ",(0,a.jsx)(n.code,{children:"withTransaction"})," call."]}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.code,{children:"optionFactory"})," is a function that takes the injected connection object and returns the adapter options object of interface:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"interface TransactionalAdapterOptions<TTx, TOptions> {\n    wrapWithTransaction: (\n        options: TOptions,\n        fn: (...args: any[]) => Promise<any>,\n        setTx: (client: TTx) => void,\n    ) => Promise<any>;\n    getFallbackInstance: () => TTx;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This object contains two methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"wrapWithTransaction"})," - a function that takes the method decorated with ",(0,a.jsx)(n.code,{children:"@Transactional"})," (or a callback passed to ",(0,a.jsx)(n.code,{children:"TransactionHost#withTransaction"}),") and wraps it with transaction handling logic. It should return a promise that resolves to the result of the decorated method.\nThe other parameter is the adapter-specific transaction ",(0,a.jsx)(n.code,{children:"options"})," object (which contains the transaction-specific options merged with the default ones) and the ",(0,a.jsx)(n.code,{children:"setTx"})," function which should be called with the transaction instance to make it available in the CLS context."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"getFallbackInstance"}),' - when a transactional context is not available, this method is used to return a "fallback" instance of the transaction object. This is needed for cases when the ',(0,a.jsx)(n.code,{children:"tx"})," property on ",(0,a.jsx)(n.code,{children:"TransactionHost"})," is accessed outside of a transactional context."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"typing",children:"Typing"}),"\n",(0,a.jsx)(n.p,{children:"The most important (and tricky) part of creating a custom adapter is to define the typing for the transaction instance."}),"\n",(0,a.jsxs)(n.p,{children:["It is important to note that the ",(0,a.jsx)(n.code,{children:"tx"})," property of ",(0,a.jsx)(n.code,{children:"TransactionHost"})," must work both ",(0,a.jsx)(n.em,{children:"inside"})," and ",(0,a.jsx)(n.em,{children:"outside"})," of a transactional context. Therefore it should not have any methods that are specific to a transactional context, because they would be unavailable outside of it (and cause runtime errors)."]}),"\n",(0,a.jsx)(n.p,{children:"For an adapter, we're going to need to define the following types:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"TConnection"}),' - a type of the "connection" object. This can be anything that lets us create an instance of the transaction.']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"TTx"})," - a type of the transaction instance. This is the type of the ",(0,a.jsx)(n.code,{children:"tx"})," property on ",(0,a.jsx)(n.code,{children:"TransactionHost"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"TOptions"})," - a type for the options object that is passed to the underlying library's transaction handling method."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"step-by-step-guide",children:"Step-by-step Guide"}),"\n",(0,a.jsxs)(n.p,{children:["In this guide, we'll show step-by-step how to create a custom adapter for the ",(0,a.jsx)(n.a,{href:"https://knexjs.org/",children:(0,a.jsx)(n.code,{children:"knex"})})," library."]}),"\n",(0,a.jsx)(n.h3,{id:"how-knex-handles-transactions",children:"How Knex handles transactions"}),"\n",(0,a.jsxs)(n.p,{children:["First, let's take a look at how ",(0,a.jsx)(n.code,{children:"knex"})," handles transactions and queries, so we can understand what we need to do to create a custom adapter for it."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { Knex } from 'knex';\n\nconst knex = Knex({\n    // [...] knex init settings\n});\n\nasync function main() {\n    // highlight-start\n    // Knex uses the transaction method on the `knex` instance to start a new transaction.\n    // highlight-end\n    await knex.transaction(\n        // highlight-start\n        // The first parameter to the method is a callback that receives a `tx` object.\n        // highlight-end\n        async (tx) => {\n            // highlight-start\n            // Within the callback, the `tx` object refers to the same transaction instance.\n            // This is what we'll need to store in the CLS context.\n            // highlight-end\n            await tx('users').insert({ name: 'John' });\n            await tx('users').insert({ name: 'Jane' });\n        },\n        // highlight-start\n        // And the second parameter is the transaction options.\n        // highlight-end\n        { isolationLevel: 'serializable' },\n    );\n\n    // highlight-start\n    // The `knex` instance itself can be used to issue queries outside of\n    // the transactional context. This is what we'll provide as the fallback.\n    // highlight-end\n    const users = await knex('users')\n        .where({ name: 'John' })\n        .orWhere({ name: 'Jane' });\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"deciding-the-typing-for-the-knex-adapter",children:"Deciding the typing for the Knex adapter"}),"\n",(0,a.jsx)(n.p,{children:"As seen above, we'll need to define the following types:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"TConnection"})," - This can be typed as ",(0,a.jsx)(n.code,{children:"Knex"})," itself, because it's the type of the ",(0,a.jsx)(n.code,{children:"knex"})," instance that we'll use to start the transaction."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"TTx"})," - While the type of the ",(0,a.jsx)(n.code,{children:"tx"})," instance passed to ",(0,a.jsx)(n.code,{children:"knex.transaction"})," is typed as ",(0,a.jsx)(n.code,{children:"Knex.Transaction"}),", it also exposes methods that are specific to the transactional context. Therefore, we'll use the base ",(0,a.jsx)(n.code,{children:"Knex"})," type here as well, because issuing queries is all that is really needed."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"TOptions"})," - Knex provides an existing type called ",(0,a.jsx)(n.code,{children:"Knex.TransactionConfig"})," for the transaction options, so we'll just use that."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,a.jsxs)(n.p,{children:["While the adapter itself can be any object that implements the ",(0,a.jsx)(n.code,{children:"TransactionalAdapter"})," interface, we'll create a class that implements it."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"export class MyTransactionalAdapterKnex\n    implements TransactionalAdapter<Knex, Knex, Knex.TransactionConfig>\n{\n    // implement the property for the connection token\n    connectionToken: any;\n\n    // implement default options feature\n    defaultTxOptions?: Partial<Knex.TransactionConfig>;\n\n    // We can decide on a custom API for the transactional adapter.\n    // In this example, we just pass individual parameters, but\n    // a custom interface is usually preferred.\n    constructor(\n        myKnexInstanceToken: any,\n        defaultTxOptions: Partial<Knex.TransactionConfig>,\n    ) {\n        this.connectionToken = myKnexInstanceToken;\n        this.defaultTxOptions = defaultTxOptions;\n    }\n\n    //\n    optionsFactory(knexInstance: Knex) {\n        return {\n            wrapWithTransaction: (\n                // the options object is the transaction-specific options merged with the default ones\n                options: Knex.TransactionConfig,\n                fn: (...args: any[]) => Promise<any>,\n                setTx: (client: Knex) => void,\n            ) => {\n                // highlight-start\n                // We'll use the `knex.transaction` method to start a new transaction.\n                // highlight-end\n                return knexInstance.transaction(\n                    (tx) => {\n                        // highlight-start\n                        // We'll call the `setTx` function with the `tx` instance\n                        // to store it in the CLS context.\n                        // highlight-end\n                        setTx(tx);\n                        // highlight-start\n                        // And then we'll call the original method.\n                        // highlight-end\n                        return fn();\n                    },\n                    // highlight-start\n                    // Don't forget to pass the options object, too\n                    // highlight-end\n                    options,\n                );\n            },\n            // highlight-start\n            // The fallback is the `knex` instance itself.\n            // highlight-end\n            getFallbackInstance: () => knexInstance,\n        };\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-the-custom-adapter",children:"Using the custom adapter"}),"\n",(0,a.jsxs)(n.p,{children:["Like any other adapter, you just pass an instance of it to the ",(0,a.jsx)(n.code,{children:"adapter"})," option of ",(0,a.jsx)(n.code,{children:"ClsPluginTransactional"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"ClsModule.forRoot({\n    plugins: [\n        new ClsPluginTransactional({\n            // Don't forget to import the module which provides the knex instance\n            imports: [KnexModule],\n            // highlight-start\n            adapter: new MyTransactionalAdapterKnex(KNEX_TOKEN, { isolationLevel: 'serializable' }),\n            // highlight-end\n        }),\n    ],\n}),\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When injecting the ",(0,a.jsx)(n.code,{children:"TransactionHost"}),", type it as ",(0,a.jsx)(n.code,{children:"TransactionHost<MyTransactionalAdapterKnex>"})," to get the correct typing of the ",(0,a.jsx)(n.code,{children:"tx"})," property."]}),"\n",(0,a.jsxs)(n.p,{children:["In a similar manner, use ",(0,a.jsx)(n.code,{children:"@Transactional<MyTransactionalAdapterKnex>()"})," to get typing for the options object."]}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"TransactionalAdapter"})," can also implement all ",(0,a.jsx)(n.a,{href:"https://docs.nestjs.com/fundamentals/lifecycle-events",children:"Lifecycle hooks"})," if there's any setup or teardown logic required."]}),(0,a.jsxs)(n.p,{children:["However, being created manually outside of Nest's control, it ",(0,a.jsx)(n.em,{children:"can not"})," inject any dependencies except for the pre-defined database connection instance via the ",(0,a.jsx)(n.code,{children:"connectionToken"}),"."]})]})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>o});var a=t(7378);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);
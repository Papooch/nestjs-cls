"use strict";(self.webpackChunknestjs_cls_docs=self.webpackChunknestjs_cls_docs||[]).push([[2336],{7986:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var s=n(4246),i=n(1670);const r={},o="Testing",c={id:"testing/index",title:"Testing",description:"Unit testing",source:"@site/docs/07_testing/index.md",sourceDirName:"07_testing",slug:"/testing/",permalink:"/nestjs-cls/testing/",draft:!1,unlisted:!1,editUrl:"https://github.com/Papooch/nestjs-cls/tree/main/docs/docs/07_testing/index.md",tags:[],version:"current",frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Plugin API",permalink:"/nestjs-cls/plugins/plugin-api"},next:{title:"Migration guide",permalink:"/nestjs-cls/migration-guide/"}},a={},l=[{value:"Unit testing",id:"unit-testing",level:2},{value:"E2E testing",id:"e2e-testing",level:2},{value:"Integration testing",id:"integration-testing",level:2},{value:"Example",id:"example",level:3}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"testing",children:"Testing"}),"\n",(0,s.jsx)(t.h2,{id:"unit-testing",children:"Unit testing"}),"\n",(0,s.jsxs)(t.p,{children:["Since the ",(0,s.jsx)(t.code,{children:"ClsService"})," and any created Proxy providers are just another injectable providers, they can be entirely mocked out in unit tests using standard techniques."]}),"\n",(0,s.jsx)(t.h2,{id:"e2e-testing",children:"E2E testing"}),"\n",(0,s.jsxs)(t.p,{children:["In E2E tests, you should use the real ",(0,s.jsx)(t.code,{children:"ClsService"})," implementation to test the entire application in a real-world scenario. Unless you're using any plugins that require special handling, you should not need to do anything special to set up E2E tests."]}),"\n",(0,s.jsx)(t.h2,{id:"integration-testing",children:"Integration testing"}),"\n",(0,s.jsxs)(t.p,{children:["In certain integration tests involving flows that span multiple modules but not the entire application, you might still want to use the real ",(0,s.jsx)(t.code,{children:"ClsService"})," implementation for context propagation."]}),"\n",(0,s.jsxs)(t.p,{children:["In that case, you will need to wrap the context-aware piece of code with a call to ",(0,s.jsx)(t.code,{children:"ClsService#run"})," or ",(0,s.jsx)(t.code,{children:"ClsService#runWith"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="cat.service.ts"',children:"@Injectable()\nexport class CatService {\n    constructor(\n        private readonly cls: ClsService,\n        private readonly catRepository: CatRepository,\n    ) {}\n\n    getCatForUser() {\n        const userId = this.cls.get('userId');\n        return this.catRepository.getForUser(userId);\n    }\n}\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="cat.service.spec.ts"',children:"describe('CatService', () => {\n  let service: CatService\n  let cls: ClsService\n  const mockCatRepository = createMock<CatRepository>()\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      // Set up most of the testing module as we normally would.\n      providers: [\n        CatService,\n        {\n          provide: CatRepository\n          useValue: mockCatRepository\n        }\n      ],\n      imports: [\n        // Import the static version of ClsModule which only provides\n        // the ClsService, but does not set up any enhancers\n        // that would automatically set up the context on request.\n        // highlight-start\n        ClsModule\n        // highlight-end\n      ],\n    }).compile()\n\n    service = module.get(CatService)\n\n    // Also retrieve the ClsService for later use.\n    cls = module.get(ClsService)\n  })\n\n  describe('getCatForUser', () => {\n    it('retrieves cat based on user id', async () => {\n      const expectedUserId = 42\n      mockCatRepository.getForUser.mockImplementationOnce(\n        (id) => ({ userId: id })\n      )\n\n      // Wrap the test call in the `runWith` method\n      // in which we can pass hand-crafted store values.\n      // highlight-start\n      const cat = await cls.runWith(\n        // populate the store with mocked values for the test\n        { userId: expectedUserId },\n        () => service.getCatForUser()\n      )\n      // highlight-end\n\n      expect(cat.userId).toEqual(expectedUserId)\n    })\n  })\n})\n"})})]})}function u(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1670:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>o});var s=n(7378);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);